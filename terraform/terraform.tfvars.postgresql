# Cypheron API - PostgreSQL Migration Configuration
# Copy this file to terraform.tfvars and customize for your environment

# Required: GCP Project Configuration
project_id = "your-gcp-project-id"
region     = "us-west1"

# Required: Security Configuration
master_admin_key     = "your-master-admin-key-minimum-32-characters"
encryption_password  = "your-encryption-password-minimum-32-characters"
# encryption_salt will be auto-generated if not provided
encryption_salt = ""

# Service Configuration
service_name = "cypheron-api"
environment  = "prod"

# Infrastructure Configuration
enable_deletion_protection = true
max_instances             = 10
min_instances             = 1
memory_limit             = "1Gi"
cpu_limit                = "1000m"

# PostgreSQL Database Configuration
use_postgresql              = true
postgres_version           = "POSTGRES_15"
postgres_tier             = "db-f1-micro"
postgres_availability_type = "ZONAL"
postgres_disk_size        = 20
postgres_max_disk_size    = 100
postgres_database_name    = "cypheron_prod"
postgres_username         = "cypheron_user"
postgres_max_connections  = 25

# Access Control
allowed_users = [
  # Example: "user:admin@yourcompany.com",
  # Example: "serviceAccount:deployment@your-project.iam.gserviceaccount.com"
]

# Configuration Notes:
# 
# 1. Security Requirements:
#    - master_admin_key: Minimum 32 characters, used for admin API access
#    - encryption_password: Minimum 32 characters, used for post-quantum encryption
#    - encryption_salt: Auto-generated if empty, used for key derivation
#
# 2. Migration Process:
#    - Set use_postgresql = false initially to keep using Firestore
#    - Deploy infrastructure with terraform apply
#    - Run migration tool to transfer data
#    - Set use_postgresql = true and redeploy to switch backends
#
# 3. Database Scaling:
#    - Start with db-f1-micro for development/testing
#    - Use db-n1-standard-* for production workloads
#    - Set postgres_availability_type = "REGIONAL" for high availability
#
# 4. Security Best Practices:
#    - Never commit this file with real secrets to version control
#    - Use environment variables or secret management for sensitive values
#    - Enable deletion_protection = true for production
#
# 5. Cost Optimization:
#    - Use ZONAL availability for cost savings in non-critical environments
#    - Adjust postgres_disk_size based on expected data volume
#    - Monitor postgres_max_connections for right-sizing
#
# Example Production Configuration:
# postgres_tier = "db-n1-standard-2"
# postgres_availability_type = "REGIONAL"
# postgres_disk_size = 100
# postgres_max_disk_size = 500
# max_instances = 20
# memory_limit = "2Gi"