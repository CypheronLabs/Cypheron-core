<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cypheron Core Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation for the Cypheron Core post-quantum cryptography library">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cypheron Core Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/CypheronLabs/Cypheron-core" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cypheron-core"><a class="header" href="#cypheron-core">Cypheron Core</a></h1>
<div class="cypheron-logo">Cypheron Core</div>
<blockquote>
<p><strong>IMPORTANT DEVELOPMENT STATUS NOTICE</strong></p>
<p><strong>This library is currently in ACTIVE DEVELOPMENT (v0.1.0) and is EXPERIMENTAL.</strong></p>
<p><strong>This is a Rust wrapper around official NIST reference implementations</strong> - not custom cryptography.
The core algorithms are NIST-certified, but the Rust integration layer has NOT undergone:</p>
<ul>
<li>Independent security audits of FFI bindings</li>
<li>Formal verification of memory safety wrappers</li>
<li>Production environment validation</li>
</ul>
<p><strong>DO NOT USE IN PRODUCTION</strong> without comprehensive integration review and testing.</p>
<p>Risk areas: FFI safety, memory management, build system - NOT the underlying NIST algorithms.</p>
</blockquote>
<p><strong>Post-quantum cryptography library implementing NIST-standardized quantum-resistant algorithms</strong></p>
<p>Cypheron Core is a Rust library implementing NIST-standardized quantum-resistant algorithms designed to protect against both classical and quantum computer attacks. The library provides high-performance implementations with strong security guarantees.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>Add to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
cypheron-core = "0.1.0"
</code></pre>
<p>Basic usage:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::{MlKem768, Kem};

// Generate keypair
let (public_key, secret_key) = MlKem768::keypair()?;

// Encapsulate shared secret  
let (ciphertext, shared_secret) = MlKem768::encapsulate(&amp;public_key)?;

// Decapsulate shared secret
let decapsulated_secret = MlKem768::decapsulate(&amp;ciphertext, &amp;secret_key)?;
assert_eq!(shared_secret.expose_secret(), decapsulated_secret.expose_secret());
<span class="boring">}</span></code></pre></pre>
<h2 id="algorithms-supported"><a class="header" href="#algorithms-supported">Algorithms Supported</a></h2>
<h3 id="key-encapsulation-mechanisms-kem"><a class="header" href="#key-encapsulation-mechanisms-kem">Key Encapsulation Mechanisms (KEM)</a></h3>
<div class="algorithm-badge">ML-KEM-512</div> <span class="security-level security-level-1">Security Level 1</span>
<div class="algorithm-badge">ML-KEM-768</div> <span class="security-level security-level-3">Security Level 3</span>  
<div class="algorithm-badge">ML-KEM-1024</div> <span class="security-level security-level-5">Security Level 5</span>
<h3 id="digital-signatures"><a class="header" href="#digital-signatures">Digital Signatures</a></h3>
<div class="algorithm-badge">ML-DSA-44</div> <span class="security-level security-level-2">Security Level 2</span>
<div class="algorithm-badge">ML-DSA-65</div> <span class="security-level security-level-3">Security Level 3</span>
<div class="algorithm-badge">ML-DSA-87</div> <span class="security-level security-level-5">Security Level 5</span>
<div class="algorithm-badge">Falcon-512</div> <span class="security-level security-level-1">Security Level 1</span>
<div class="algorithm-badge">Falcon-1024</div> <span class="security-level security-level-5">Security Level 5</span>
<div class="algorithm-badge">SPHINCS+</div> Multiple variants available
<h3 id="hybrid-cryptography"><a class="header" href="#hybrid-cryptography">Hybrid Cryptography</a></h3>
<ul>
<li><strong>ECC + ML-DSA</strong>: Classical elliptic curve + post-quantum signatures</li>
<li><strong>Hybrid KEM</strong>: Combined classical and post-quantum key agreement</li>
</ul>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Algorithm</th><th>Key Gen</th><th>Sign/Encaps</th><th>Verify/Decaps</th></tr></thead><tbody>
<tr><td>ML-KEM-768</td><td><span data-perf="Average: 0.05ms on modern CPUs">~50μs</span></td><td><span data-perf="Average: 0.06ms on modern CPUs">~60μs</span></td><td><span data-perf="Average: 0.08ms on modern CPUs">~80μs</span></td></tr>
<tr><td>ML-DSA-65</td><td><span data-perf="Average: 0.12ms on modern CPUs">~120μs</span></td><td><span data-perf="Average: 0.25ms on modern CPUs">~250μs</span></td><td><span data-perf="Average: 0.11ms on modern CPUs">~110μs</span></td></tr>
</tbody></table>
</div>
<h2 id="security-features"><a class="header" href="#security-features">Security Features</a></h2>
<ul>
<li><strong>Side-channel resistance</strong>: Constant-time implementations</li>
<li><strong>Memory safety</strong>: Secure key zeroization</li>
<li><strong>NIST compliance</strong>: Implements FIPS 203, 204, 205 standards</li>
<li><strong>Production hardened</strong>: Extensive testing and validation</li>
</ul>
<h2 id="documentation-sections"><a class="header" href="#documentation-sections">Documentation Sections</a></h2>
<ul>
<li><strong><a href="getting-started/installation.html">Getting Started</a></strong> - Installation and basic usage</li>
<li><strong><a href="api/types.html">API Reference</a></strong> - Complete API documentation</li>
<li><strong><a href="algorithms/ml-kem.html">Algorithms</a></strong> - Detailed algorithm documentation</li>
<li><strong><a href="security/model.html">Security</a></strong> - Security model and considerations</li>
<li><strong><a href="troubleshooting/common.html">Troubleshooting</a></strong> - Common issues and solutions</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>When you encounter errors, they include direct links to relevant documentation:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match MlKem768::keypair() {
    Ok((pk, sk)) =&gt; { /* use keys */ },
    Err(e) =&gt; {
        // Error includes link: ERROR-KEM-001
        // See: https://docs.rs/cypheron-core/troubleshooting/errors.html#error-kem-001
        eprintln!("Key generation failed: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="local-development"><a class="header" href="#local-development">Local Development</a></h2>
<p>Run the documentation locally:</p>
<pre><code class="language-bash"># Install mdBook
cargo install mdbook

# Serve documentation with hot reload
cd docs
mdbook serve

# Open http://localhost:3000 in your browser
</code></pre>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Licensed under the Apache License 2.0. See <a href="../LICENSE">LICENSE</a> for details.</p>
<hr />
<div class="warning-box">
<strong>Development Status:</strong> This library (v0.1.0) contains experimental implementations and has not been audited. DO NOT USE IN PRODUCTION without thorough security review. Built with C vendor code + Rust FFI requiring careful validation. See <a href="security/model.html">Security Model</a> for details.
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h2>
<ul>
<li><strong>Rust</strong>: 1.80 or higher</li>
<li><strong>Operating System</strong>: Linux, macOS, or Windows</li>
<li><strong>Architecture</strong>: x86_64, aarch64</li>
</ul>
<h2 id="cargo-installation"><a class="header" href="#cargo-installation">Cargo Installation</a></h2>
<p>Add Cypheron Core to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
cypheron-core = "0.1.0"
</code></pre>
<p>Then run:</p>
<pre><code class="language-bash">cargo build
</code></pre>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<p>Cypheron Core supports optional features:</p>
<pre><code class="language-toml">[dependencies]
cypheron-core = { version = "0.1.0", features = ["std", "alloc"] }
</code></pre>
<p>Available features:</p>
<ul>
<li><code>std</code> (default): Standard library support</li>
<li><code>alloc</code>: Allocation support for <code>no_std</code> environments</li>
<li><code>hybrid</code>: Hybrid cryptography algorithms</li>
<li><code>serialize</code>: Serde serialization support</li>
</ul>
<h2 id="no-std-support"><a class="header" href="#no-std-support">No-std Support</a></h2>
<p>For embedded and constrained environments:</p>
<pre><code class="language-toml">[dependencies]
cypheron-core = { version = "0.1.0", default-features = false, features = ["alloc"] }
</code></pre>
<h2 id="development-dependencies"><a class="header" href="#development-dependencies">Development Dependencies</a></h2>
<p>For testing and benchmarking:</p>
<pre><code class="language-toml">[dev-dependencies]
cypheron-core = { version = "0.1.0", features = ["test-utils"] }
criterion = "0.5"
</code></pre>
<h2 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-Specific Notes</a></h2>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>No additional dependencies required.</p>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>Ensure Xcode command line tools are installed:</p>
<pre><code class="language-bash">xcode-select --install
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>Requires Visual Studio Build Tools or MSVC.</p>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>Verify your installation:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use cypheron_core::kem::{MlKem768, Kem};

fn main() {
    match MlKem768::keypair() {
        Ok(_) =&gt; println!("Installation successful!"),
        Err(e) =&gt; eprintln!("Installation issue: {}", e),
    }
}</code></pre></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="getting-started/quick-start.html">Quick Start Guide</a> - Basic usage examples</li>
<li><a href="getting-started/../api/types.html">API Reference</a> - Complete API documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-guide"><a class="header" href="#quick-start-guide">Quick Start Guide</a></h1>
<p>Get up and running with Cypheron Core in minutes.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Add cypheron-core to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
cypheron-core = "0.1.0"
</code></pre>
<h2 id="basic-kem-example"><a class="header" href="#basic-kem-example">Basic KEM Example</a></h2>
<p>Key Encapsulation Mechanisms (KEMs) are used for secure key exchange:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use cypheron_core::kem::{MlKem768, Kem};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Generate a keypair
    let (public_key, secret_key) = MlKem768::keypair()?;
    
    // Alice encapsulates a shared secret using Bob's public key
    let (ciphertext, shared_secret_alice) = MlKem768::encapsulate(&amp;public_key)?;
    
    // Bob decapsulates the shared secret using his secret key
    let shared_secret_bob = MlKem768::decapsulate(&amp;ciphertext, &amp;secret_key)?;
    
    // Both parties now have the same shared secret
    assert_eq!(shared_secret_alice.expose_secret(), shared_secret_bob.expose_secret());
    
    println!("Key exchange successful!");
    Ok(())
}</code></pre></pre>
<h2 id="basic-signature-example"><a class="header" href="#basic-signature-example">Basic Signature Example</a></h2>
<p>Digital signatures provide authentication and non-repudiation:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use cypheron_core::sig::{MlDsa65, SignatureEngine};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let message = b"Hello, post-quantum world!";
    
    // Generate signing keypair
    let (public_key, secret_key) = MlDsa65::keypair()?;
    
    // Sign the message
    let signature = MlDsa65::sign(message, &amp;secret_key)?;
    
    // Verify the signature
    let is_valid = MlDsa65::verify(message, &amp;signature, &amp;public_key);
    
    assert!(is_valid);
    println!("Signature verification successful!");
    Ok(())
}</code></pre></pre>
<h2 id="hybrid-example"><a class="header" href="#hybrid-example">Hybrid Example</a></h2>
<p>Combine classical and post-quantum security:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use cypheron_core::hybrid::{EccDilithium, HybridEngine};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let message = b"Hybrid security message";
    
    // Generate hybrid keypair (ECC + ML-DSA)
    let (public_key, secret_key) = EccDilithium::keypair()?;
    
    // Create hybrid signature
    let signature = EccDilithium::sign(message, &amp;secret_key)?;
    
    // Verify with different policies
    use cypheron_core::hybrid::VerificationPolicy;
    
    // Require both classical and post-quantum signatures to be valid
    let strict_valid = EccDilithium::verify_with_policy(
        message, 
        &amp;signature, 
        &amp;public_key, 
        VerificationPolicy::BothRequired
    );
    
    // Accept if either classical OR post-quantum signature is valid
    let relaxed_valid = EccDilithium::verify_with_policy(
        message, 
        &amp;signature, 
        &amp;public_key, 
        VerificationPolicy::EitherValid
    );
    
    println!("Strict policy: {}", strict_valid);
    println!("Relaxed policy: {}", relaxed_valid);
    
    Ok(())
}</code></pre></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>Cypheron Core uses structured error types with helpful messages:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::{MlKem768, Kem};

match MlKem768::keypair() {
    Ok((pk, sk)) =&gt; {
        println!("Keypair generated successfully");
        // Use the keys...
    },
    Err(e) =&gt; {
        eprintln!("Key generation failed: {}", e);
        // Error codes like ERROR-KEM-001 link to documentation
        // See troubleshooting/errors.md for complete error reference
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="memory-safety"><a class="header" href="#memory-safety">Memory Safety</a></h2>
<p>All sensitive data is automatically zeroized when dropped:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::{MlKem768, Kem};

{
    let (public_key, secret_key) = MlKem768::keypair().unwrap();
    // Use keys...
} // secret_key is automatically zeroized when it goes out of scope
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><strong><a href="getting-started/../algorithms/ml-kem.html">Algorithm Details</a></strong> - Learn about specific algorithms</li>
<li><strong><a href="getting-started/../api/types.html">API Reference</a></strong> - Complete API documentation</li>
<li><strong><a href="getting-started/../security/model.html">Security Model</a></strong> - Understanding security guarantees</li>
<li><strong><a href="getting-started/../performance/optimization.html">Performance Guide</a></strong> - Optimizing your application</li>
</ul>
<h2 id="production-checklist"><a class="header" href="#production-checklist">Production Checklist</a></h2>
<p>Before using in production:</p>
<ol>
<li>Read the <a href="getting-started/../security/model.html">Security Model</a></li>
<li>Review <a href="getting-started/../security/compliance.html">Compliance Requirements</a></li>
<li>Set up <a href="getting-started/../deployment/monitoring.html">Monitoring</a></li>
<li>Test your <a href="getting-started/../troubleshooting/common.html">Error Handling</a></li>
<li>Performance test with <a href="getting-started/../performance/benchmarks.html">Benchmarking Guide</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-examples"><a class="header" href="#basic-examples">Basic Examples</a></h1>
<p>Complete working examples to get you started with Cypheron Core.</p>
<h2 id="key-encapsulation-kem-example"><a class="header" href="#key-encapsulation-kem-example">Key Encapsulation (KEM) Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::{MlKem768, Kem};
use cypheron_core::SecretBox;

fn kem_example() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Alice generates a keypair
    let (alice_pk, alice_sk) = MlKem768::keypair()?;
    
    // Bob wants to send a secret to Alice
    // He encapsulates using Alice's public key
    let (ciphertext, shared_secret_bob) = MlKem768::encapsulate(&amp;alice_pk)?;
    
    // Alice decapsulates using her secret key
    let shared_secret_alice = MlKem768::decapsulate(&amp;ciphertext, &amp;alice_sk)?;
    
    // Both parties now have the same shared secret
    assert_eq!(
        shared_secret_alice.expose_secret(),
        shared_secret_bob.expose_secret()
    );
    
    println!("Shared secret exchange successful!");
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="digital-signature-example"><a class="header" href="#digital-signature-example">Digital Signature Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::sig::{MlDsa65, SignatureEngine};

fn signature_example() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let document = b"Important contract terms...";
    
    // Alice generates signing keys
    let (verify_key, signing_key) = MlDsa65::keypair()?;
    
    // Alice signs the document
    let signature = MlDsa65::sign(document, &amp;signing_key)?;
    
    // Bob verifies Alice's signature
    let is_valid = MlDsa65::verify(document, &amp;signature, &amp;verify_key);
    
    if is_valid {
        println!("Signature is valid - document authenticated!");
    } else {
        println!("Invalid signature - document may be tampered!");
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="hybrid-signature-example"><a class="header" href="#hybrid-signature-example">Hybrid Signature Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::hybrid::{EccDilithium, HybridEngine, VerificationPolicy};

fn hybrid_example() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let message = b"Quantum-safe hybrid message";
    
    // Generate hybrid keypair (ECC + ML-DSA)
    let (public_key, secret_key) = EccDilithium::keypair()?;
    
    // Create hybrid signature
    let signature = EccDilithium::sign(message, &amp;secret_key)?;
    
    // Verify with strict policy (both signatures must be valid)
    let strict_valid = EccDilithium::verify_with_policy(
        message,
        &amp;signature,
        &amp;public_key,
        VerificationPolicy::BothRequired
    );
    
    // Verify with relaxed policy (either signature valid)
    let relaxed_valid = EccDilithium::verify_with_policy(
        message,
        &amp;signature,
        &amp;public_key,
        VerificationPolicy::EitherValid
    );
    
    println!("Strict policy result: {}", strict_valid);
    println!("Relaxed policy result: {}", relaxed_valid);
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-example"><a class="header" href="#error-handling-example">Error Handling Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::{MlKem768, Kem, MlKemError};

fn error_handling_example() {
    match MlKem768::keypair() {
        Ok((pk, sk)) =&gt; {
            println!("Keys generated successfully");
            
            // Try to encapsulate
            match MlKem768::encapsulate(&amp;pk) {
                Ok((ct, ss)) =&gt; {
                    println!("Encapsulation successful");
                    
                    // Try to decapsulate
                    match MlKem768::decapsulate(&amp;ct, &amp;sk) {
                        Ok(decrypted_ss) =&gt; {
                            println!("Decapsulation successful");
                        },
                        Err(e) =&gt; {
                            eprintln!("Decapsulation failed: {}", e);
                            // Error includes helpful documentation links
                        }
                    }
                },
                Err(e) =&gt; eprintln!("Encapsulation failed: {}", e),
            }
        },
        Err(e) =&gt; {
            eprintln!("Key generation failed: {}", e);
            // Errors include ERROR-KEM-XXX codes linking to docs
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="memory-safety-example"><a class="header" href="#memory-safety-example">Memory Safety Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::{MlKem768, Kem};
use cypheron_core::SecretBox;

fn memory_safety_example() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let shared_secret = {
        let (pk, sk) = MlKem768::keypair()?;
        let (ct, ss) = MlKem768::encapsulate(&amp;pk)?;
        
        // Secret key `sk` is automatically zeroized when it goes out of scope
        ss
    }; // Keys are now securely zeroized
    
    // Shared secret is still valid and secure
    println!("Shared secret length: {}", shared_secret.expose_secret().len());
    
    // When shared_secret goes out of scope, it will be zeroized
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-application-example"><a class="header" href="#complete-application-example">Complete Application Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use cypheron_core::kem::{MlKem768, Kem};
use cypheron_core::sig::{MlDsa65, SignatureEngine};

struct SecureMessage {
    encrypted_data: Vec&lt;u8&gt;,
    signature: Vec&lt;u8&gt;,
}

fn secure_messaging_example() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Alice's keys for encryption
    let (alice_kem_pk, alice_kem_sk) = MlKem768::keypair()?;
    
    // Bob's keys for signing  
    let (bob_sig_pk, bob_sig_sk) = MlDsa65::keypair()?;
    
    let plaintext = b"Confidential message from Bob to Alice";
    
    // Bob encrypts message for Alice
    let (ciphertext, shared_secret) = MlKem768::encapsulate(&amp;alice_kem_pk)?;
    
    // Use shared secret to encrypt data (simplified - in practice use AES-GCM)
    let mut encrypted_data = plaintext.to_vec();
    for (i, byte) in encrypted_data.iter_mut().enumerate() {
        *byte ^= shared_secret.expose_secret()[i % 32];
    }
    
    // Bob signs the encrypted message
    let signature = MlDsa65::sign(&amp;encrypted_data, &amp;bob_sig_sk)?;
    
    let secure_msg = SecureMessage {
        encrypted_data,
        signature,
    };
    
    // Alice receives and verifies the message
    // First verify Bob's signature
    let signature_valid = MlDsa65::verify(
        &amp;secure_msg.encrypted_data,
        &amp;secure_msg.signature,
        &amp;bob_sig_pk
    );
    
    if !signature_valid {
        return Err("Invalid signature!".into());
    }
    
    // Then decrypt using her private key
    let decrypted_secret = MlKem768::decapsulate(&amp;ciphertext, &amp;alice_kem_sk)?;
    
    // Decrypt the message
    let mut decrypted_data = secure_msg.encrypted_data.clone();
    for (i, byte) in decrypted_data.iter_mut().enumerate() {
        *byte ^= decrypted_secret.expose_secret()[i % 32];
    }
    
    println!("Decrypted message: {}", String::from_utf8_lossy(&amp;decrypted_data));
    
    Ok(())
}

fn main() {
    if let Err(e) = secure_messaging_example() {
        eprintln!("Secure messaging failed: {}", e);
    }
}</code></pre></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li><a href="getting-started/../algorithms/ml-kem.html">Algorithm Details</a> - Learn about specific algorithms</li>
<li><a href="getting-started/../security/model.html">Security Model</a> - Understand security guarantees</li>
<li><a href="getting-started/../performance/optimization.html">Performance Guide</a> - Optimize your applications</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-roadmap"><a class="header" href="#development-roadmap">Development Roadmap</a></h1>
<p>This section provides an overview of Cypheron Core’s development timeline and current priorities.</p>
<p>For complete details, see the full <a href="getting-started/../../ROADMAP.html">Development Roadmap</a>.</p>
<h2 id="current-status-v011---foundation-complete-september-2025"><a class="header" href="#current-status-v011---foundation-complete-september-2025">Current Status: v0.1.1 - Foundation Complete (September 2025)</a></h2>
<p><strong>Status:</strong> [X] <strong>COMPLETED</strong> - Core implementation and documentation finished<br />
<strong>Achievement:</strong> Full post-quantum algorithm implementation with comprehensive security documentation</p>
<h3 id="x-completed-foundation-work"><a class="header" href="#x-completed-foundation-work">[X] Completed Foundation Work</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Complete unsafe code documentation and justification</li>
<li><input disabled="" type="checkbox" checked=""/>
Architecture documentation with FFI boundary analysis</li>
<li><input disabled="" type="checkbox" checked=""/>
Security vulnerability reporting policy</li>
<li><input disabled="" type="checkbox" checked=""/>
Comprehensive security testing suite</li>
<li><input disabled="" type="checkbox" checked=""/>
Cross-platform implementation (Linux, macOS, Windows)</li>
<li><input disabled="" type="checkbox" checked=""/>
Supply chain integrity verification system</li>
<li><input disabled="" type="checkbox" checked=""/>
Memory safety validation and documentation</li>
</ul>
<h2 id="current-priorities-q4-2025"><a class="header" href="#current-priorities-q4-2025">Current Priorities: Q4 2025</a></h2>
<p><strong>Focus:</strong> Community Audit and Funding Phase</p>
<h3 id="community-audit-initiative"><a class="header" href="#community-audit-initiative">Community Audit Initiative</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Open source community security review</li>
<li><input disabled="" type="checkbox"/>
Academic cryptography community feedback</li>
<li><input disabled="" type="checkbox"/>
Independent security researcher analysis</li>
<li><input disabled="" type="checkbox"/>
Community-driven testing and validation</li>
</ul>
<h3 id="grant-funding-and-support"><a class="header" href="#grant-funding-and-support">Grant Funding and Support</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Research foundation grant applications</li>
<li><input disabled="" type="checkbox"/>
Open source security initiative funding</li>
<li><input disabled="" type="checkbox"/>
Academic institution partnership opportunities</li>
<li><input disabled="" type="checkbox"/>
Government cybersecurity grant programs</li>
</ul>
<h2 id="2026-goals-production-release"><a class="header" href="#2026-goals-production-release">2026 Goals: Production Release</a></h2>
<p>Following successful security audit and validation:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Production-ready release with security audit approval</li>
<li><input disabled="" type="checkbox"/>
Long-term API stability commitment</li>
<li><input disabled="" type="checkbox"/>
Enterprise deployment support</li>
<li><input disabled="" type="checkbox"/>
Comprehensive documentation for production use</li>
</ul>
<h2 id="algorithm-implementation-status"><a class="header" href="#algorithm-implementation-status">Algorithm Implementation Status</a></h2>
<h3 id="x-complete-implementations"><a class="header" href="#x-complete-implementations">[X] Complete Implementations</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
ML-KEM (Kyber) - 512, 768, 1024 bit security levels</li>
<li><input disabled="" type="checkbox" checked=""/>
ML-DSA (Dilithium) - Levels 2, 3, 5</li>
<li><input disabled="" type="checkbox" checked=""/>
Falcon - 512, 1024 bit variants</li>
<li><input disabled="" type="checkbox" checked=""/>
SPHINCS+ - Multiple parameter configurations</li>
<li><input disabled="" type="checkbox" checked=""/>
Hybrid cryptography support (Classical + PQ combinations)</li>
</ul>
<h2 id="how-to-get-involved"><a class="header" href="#how-to-get-involved">How to Get Involved</a></h2>
<h3 id="security-review"><a class="header" href="#security-review">Security Review</a></h3>
<ul>
<li>Review our <a href="getting-started/../security/model.html">Security Documentation</a></li>
<li>Examine <a href="getting-started/../security/unsafe-guide.html">Unsafe Code Guide</a></li>
<li>Report findings via <a href="getting-started/../security/reporting.html">Security Policy</a></li>
</ul>
<h3 id="development"><a class="header" href="#development">Development</a></h3>
<ul>
<li>See <a href="getting-started/../development/contributing.html">Contributing Guidelines</a></li>
<li>Review <a href="getting-started/../development/build.html">Build System</a> documentation</li>
<li>Participate in <a href="getting-started/../development/testing.html">Testing</a> efforts</li>
</ul>
<p>For the complete roadmap with detailed timelines and success metrics, see <a href="getting-started/../../ROADMAP.html">ROADMAP.md</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ml-kem-module-lattice-based-key-encapsulation-mechanism"><a class="header" href="#ml-kem-module-lattice-based-key-encapsulation-mechanism">ML-KEM (Module-Lattice-Based Key Encapsulation Mechanism)</a></h1>
<p>ML-KEM is the NIST-standardized quantum-resistant key encapsulation mechanism, formerly known as Kyber. It enables secure key exchange that is resistant to both classical and quantum computer attacks.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>ML-KEM is based on the Module Learning With Errors (M-LWE) problem, which is believed to be hard even for quantum computers. The algorithm provides:</p>
<ul>
<li><strong>Key Encapsulation</strong>: Secure key exchange between parties</li>
<li><strong>Quantum Resistance</strong>: Security against Shor’s algorithm</li>
<li><strong>Performance</strong>: Efficient operations suitable for real-world use</li>
<li><strong>Standardization</strong>: NIST FIPS 203 compliance</li>
</ul>
<h2 id="security-levels"><a class="header" href="#security-levels">Security Levels</a></h2>
<p>Cypheron Core implements all three ML-KEM variants:</p>
<div class="table-wrapper"><table><thead><tr><th>Variant</th><th>Security Level</th><th>Classical Security</th><th>Quantum Security</th><th>Key Sizes</th></tr></thead><tbody>
<tr><td>ML-KEM-512</td><td>1</td><td>~128-bit</td><td>~64-bit</td><td>PK: 800B, SK: 1632B</td></tr>
<tr><td>ML-KEM-768</td><td>3</td><td>~192-bit</td><td>~96-bit</td><td>PK: 1184B, SK: 2400B</td></tr>
<tr><td>ML-KEM-1024</td><td>5</td><td>~256-bit</td><td>~128-bit</td><td>PK: 1568B, SK: 3168B</td></tr>
</tbody></table>
</div>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::{MlKem768, Kem};

// Generate keypair
let (public_key, secret_key) = MlKem768::keypair()?;

// Alice encapsulates a shared secret
let (ciphertext, shared_secret_alice) = MlKem768::encapsulate(&amp;public_key)?;

// Bob decapsulates the shared secret
let shared_secret_bob = MlKem768::decapsulate(&amp;ciphertext, &amp;secret_key)?;

// Both parties have the same 32-byte shared secret
assert_eq!(shared_secret_alice.expose_secret(), shared_secret_bob.expose_secret());
<span class="boring">}</span></code></pre></pre>
<h2 id="algorithm-details"><a class="header" href="#algorithm-details">Algorithm Details</a></h2>
<h3 id="key-generation"><a class="header" href="#key-generation">Key Generation</a></h3>
<ol>
<li>Generate matrix <strong>A</strong> from public randomness</li>
<li>Generate secret vectors <strong>s</strong> and <strong>e</strong> from centered binomial distribution</li>
<li>Compute <strong>t = A·s + e</strong></li>
<li>Public key: <strong>(ρ, t)</strong>, Secret key: <strong>s</strong></li>
</ol>
<h3 id="encapsulation"><a class="header" href="#encapsulation">Encapsulation</a></h3>
<ol>
<li>Generate ephemeral secret <strong>r</strong> and error vectors <strong>e1</strong>, <strong>e2</strong></li>
<li>Compute <strong>u = A^T·r + e1</strong></li>
<li>Compute <strong>v = t^T·r + e2 + Encode(m)</strong></li>
<li>Return ciphertext <strong>(u, v)</strong> and shared secret <strong>KDF(m)</strong></li>
</ol>
<h3 id="decapsulation"><a class="header" href="#decapsulation">Decapsulation</a></h3>
<ol>
<li>Compute <strong>m’ = Decode(v - s^T·u)</strong></li>
<li>Re-encapsulate with <strong>m’</strong> to get <strong>(u’, v’)</strong></li>
<li>If <strong>(u’, v’) = (u, v)</strong>, return <strong>KDF(m’)</strong>, else return <strong>KDF(z)</strong></li>
</ol>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<p>ML-KEM operations are highly efficient:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;
use cypheron_core::kem::{MlKem768, Kem};

fn benchmark_ml_kem() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Key generation
    let start = Instant::now();
    let (pk, sk) = MlKem768::keypair()?;
    println!("Keygen: {:?}", start.elapsed());
    
    // Encapsulation  
    let start = Instant::now();
    let (ct, ss1) = MlKem768::encapsulate(&amp;pk)?;
    println!("Encaps: {:?}", start.elapsed());
    
    // Decapsulation
    let start = Instant::now();
    let ss2 = MlKem768::decapsulate(&amp;ct, &amp;sk)?;
    println!("Decaps: {:?}", start.elapsed());
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="proper-usage"><a class="header" href="#proper-usage">Proper Usage</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::{MlKem768, Kem};

// Correct: Use each key pair only once
let (pk, sk) = MlKem768::keypair()?;
let (ct, ss) = MlKem768::encapsulate(&amp;pk)?;

// Correct: Validate ciphertext before decapsulation
if ct.len() == 1088 { // ML-KEM-768 ciphertext size
    let ss2 = MlKem768::decapsulate(&amp;ct, &amp;sk)?;
}

// Incorrect: Reusing the same keypair multiple times
// This could leak information about the secret key
<span class="boring">}</span></code></pre></pre>
<h3 id="side-channel-protection"><a class="header" href="#side-channel-protection">Side-Channel Protection</a></h3>
<p>All operations use constant-time implementations:</p>
<ul>
<li><strong>Constant-time sampling</strong>: Secret values don’t affect execution time</li>
<li><strong>Constant-time arithmetic</strong>: Operations always take the same time</li>
<li><strong>Memory access patterns</strong>: No secret-dependent memory accesses</li>
</ul>
<h2 id="migration-from-kyber"><a class="header" href="#migration-from-kyber">Migration from Kyber</a></h2>
<p>Cypheron Core provides compatibility aliases for smooth migration:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Old Kyber code
use cypheron_core::kem::{Kyber768, KyberError}; // Deprecated

// New ML-KEM code  
use cypheron_core::kem::{MlKem768, MlKemError}; // Recommended

// Both interfaces are identical
let (pk, sk) = MlKem768::keypair()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="test-vectors"><a class="header" href="#test-vectors">Test Vectors</a></h2>
<p>Validation against NIST test vectors:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_nist_vectors() {
        // Test against official NIST ML-KEM test vectors
        // See tests/kat/ directory for complete vectors
        let (pk, sk) = MlKem768::keypair().unwrap(); 
        let (ct, ss1) = MlKem768::encapsulate(&amp;pk).unwrap();
        let ss2 = MlKem768::decapsulate(&amp;ct, &amp;sk).unwrap();
        assert_eq!(ss1.expose_secret(), ss2.expose_secret());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="variants"><a class="header" href="#variants">Variants</a></h2>
<ul>
<li><strong><a href="algorithms/ml-kem/ml-kem-512.html">ML-KEM-512</a></strong> - Security Level 1</li>
<li><strong><a href="algorithms/ml-kem/ml-kem-768.html">ML-KEM-768</a></strong> - Security Level 3 (Recommended)</li>
<li><strong><a href="algorithms/ml-kem/ml-kem-1024.html">ML-KEM-1024</a></strong> - Security Level 5</li>
</ul>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="algorithms/../api/kem.html">KEM Operations API</a></li>
<li><a href="algorithms/../performance/benchmarks.html">Performance Benchmarks</a></li>
<li><a href="algorithms/../security/model.html">Security Model</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ml-dsa-digital-signatures"><a class="header" href="#ml-dsa-digital-signatures">ML-DSA (Digital Signatures)</a></h1>
<p>ML-DSA (Module-Lattice-Based Digital Signature Algorithm) is the NIST-standardized post-quantum digital signature scheme, based on the Dilithium algorithm.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>ML-DSA is designed to resist attacks from both classical and quantum computers, providing:</p>
<ul>
<li><strong>Quantum Resistance</strong>: Security against Shor’s algorithm</li>
<li><strong>Efficiency</strong>: Fast signature generation and verification</li>
<li><strong>Small Signatures</strong>: Compact signature sizes for practical deployment</li>
<li><strong>NIST Standardized</strong>: FIPS 204 compliant implementation</li>
</ul>
<h2 id="security-levels-1"><a class="header" href="#security-levels-1">Security Levels</a></h2>
<p>Cypheron Core implements three ML-DSA variants:</p>
<div class="table-wrapper"><table><thead><tr><th>Variant</th><th>Security Level</th><th>Public Key</th><th>Secret Key</th><th>Signature</th></tr></thead><tbody>
<tr><td>ML-DSA-44</td><td>Level 2 (~112-bit)</td><td>1,312 bytes</td><td>2,560 bytes</td><td>2,420 bytes</td></tr>
<tr><td>ML-DSA-65</td><td>Level 3 (~128-bit)</td><td>1,952 bytes</td><td>4,032 bytes</td><td>3,293 bytes</td></tr>
<tr><td>ML-DSA-87</td><td>Level 5 (~256-bit)</td><td>2,592 bytes</td><td>4,896 bytes</td><td>4,595 bytes</td></tr>
</tbody></table>
</div>
<h2 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h2>
<h3 id="key-generation-1"><a class="header" href="#key-generation-1">Key Generation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::sig::{MlDsa65, DigitalSignature};

// Generate a new keypair
let (public_key, secret_key) = MlDsa65::keypair()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="message-signing"><a class="header" href="#message-signing">Message Signing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let message = b"Hello, post-quantum world!";

// Sign the message
let signature = MlDsa65::sign(&amp;secret_key, message)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="signature-verification"><a class="header" href="#signature-verification">Signature Verification</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Verify the signature
let is_valid = MlDsa65::verify(&amp;public_key, message, &amp;signature)?;
assert!(is_valid);
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<h3 id="deterministic-key-generation"><a class="header" href="#deterministic-key-generation">Deterministic Key Generation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::sig::MlDsa65;

// Generate keypair from seed (for testing)
let seed = [42u8; 32];
let (pk, sk) = MlDsa65::keypair_deterministic(&amp;seed)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="context-separation"><a class="header" href="#context-separation">Context Separation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sign with context for domain separation
let context = b"email-signature-v1";
let signature = MlDsa65::sign_with_context(&amp;secret_key, message, context)?;
let is_valid = MlDsa65::verify_with_context(&amp;public_key, message, &amp;signature, context)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h2>
<h3 id="recommended-usage"><a class="header" href="#recommended-usage">Recommended Usage</a></h3>
<ul>
<li><strong>Use ML-DSA-65</strong> for most applications (128-bit security level)</li>
<li><strong>Use ML-DSA-87</strong> for high-security applications requiring 256-bit security</li>
<li><strong>Use ML-DSA-44</strong> only for resource-constrained environments</li>
</ul>
<h3 id="key-management"><a class="header" href="#key-management">Key Management</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use secrecy::{ExposeSecret, Zeroize};

// Secret keys are automatically zeroized on drop
impl Drop for MlDsaSecretKey {
    fn drop(&amp;mut self) {
        self.0.zeroize();
    }
}

// Access secret key material safely
secret_key.expose_secret(|key_bytes| {
    // Use key_bytes for signing operation
    MlDsa65::sign_with_raw_key(key_bytes, message)
})
<span class="boring">}</span></code></pre></pre>
<h3 id="side-channel-resistance"><a class="header" href="#side-channel-resistance">Side-Channel Resistance</a></h3>
<ul>
<li>Implementation uses constant-time operations where feasible</li>
<li>Secret key operations avoid data-dependent branches</li>
<li>Memory access patterns independent of secret values</li>
</ul>
<h2 id="performance-characteristics-1"><a class="header" href="#performance-characteristics-1">Performance Characteristics</a></h2>
<h3 id="typical-performance-x86_64-30-ghz"><a class="header" href="#typical-performance-x86_64-30-ghz">Typical Performance (x86_64, 3.0 GHz)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>ML-DSA-44</th><th>ML-DSA-65</th><th>ML-DSA-87</th></tr></thead><tbody>
<tr><td>Key Generation</td><td>~95μs</td><td>~120μs</td><td>~160μs</td></tr>
<tr><td>Sign</td><td>~180μs</td><td>~250μs</td><td>~380μs</td></tr>
<tr><td>Verify</td><td>~85μs</td><td>~110μs</td><td>~150μs</td></tr>
</tbody></table>
</div>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<ul>
<li>Stack allocation for all operations</li>
<li>No dynamic memory allocation required</li>
<li>Secure automatic cleanup on scope exit</li>
</ul>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<h3 id="common-errors"><a class="header" href="#common-errors">Common Errors</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::error::Error;

match MlDsa65::verify(&amp;public_key, message, &amp;signature) {
    Ok(true) =&gt; println!("Valid signature"),
    Ok(false) =&gt; println!("Invalid signature"),
    Err(Error::InvalidPublicKey) =&gt; println!("Malformed public key"),
    Err(Error::InvalidSignature) =&gt; println!("Malformed signature"),
    Err(e) =&gt; println!("Other error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="input-validation"><a class="header" href="#input-validation">Input Validation</a></h3>
<ul>
<li>All inputs are validated before processing</li>
<li>Malformed keys/signatures return appropriate errors</li>
<li>No panics on invalid input data</li>
</ul>
<h2 id="interoperability"><a class="header" href="#interoperability">Interoperability</a></h2>
<h3 id="nist-compliance"><a class="header" href="#nist-compliance">NIST Compliance</a></h3>
<ul>
<li>Implements FIPS 204 specification exactly</li>
<li>Compatible with other FIPS 204 implementations</li>
<li>Passes all NIST Known Answer Tests (KAT)</li>
</ul>
<h3 id="serialization"><a class="header" href="#serialization">Serialization</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Serialize keys and signatures
let pk_bytes = public_key.as_bytes();
let sk_bytes = secret_key.expose_secret(|bytes| bytes.to_vec());
let sig_bytes = signature.as_bytes();

// Deserialize from bytes
let public_key = MlDsaPublicKey::from_bytes(&amp;pk_bytes)?;
let signature = MlDsaSignature::from_bytes(&amp;sig_bytes)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="hybrid-signatures"><a class="header" href="#hybrid-signatures">Hybrid Signatures</a></h2>
<p>ML-DSA can be combined with classical signatures for transitional security:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::hybrid::EccDilithium;

// Hybrid ECDSA + ML-DSA signature
let (hybrid_pk, hybrid_sk) = EccDilithium::keypair()?;
let hybrid_sig = EccDilithium::sign(&amp;hybrid_sk, message)?;
let is_valid = EccDilithium::verify(&amp;hybrid_pk, message, &amp;hybrid_sig)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="algorithms/falcon.html">Falcon Digital Signatures</a> - Alternative post-quantum signature scheme</li>
<li><a href="algorithms/sphincsplus.html">SPHINCS+ Digital Signatures</a> - Hash-based signature scheme</li>
<li><a href="algorithms/../hybrid/overview.html">Hybrid Cryptography</a> - Combining classical and post-quantum</li>
<li><a href="algorithms/../security/model.html">Security Model</a> - Overall security considerations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="falcon-digital-signatures"><a class="header" href="#falcon-digital-signatures">Falcon (Digital Signatures)</a></h1>
<p>Falcon is a post-quantum digital signature scheme based on the NTRU lattice structure, offering compact signatures and fast verification.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>Falcon provides:</p>
<ul>
<li><strong>Compact Signatures</strong>: Smallest signature sizes among post-quantum schemes</li>
<li><strong>Fast Verification</strong>: Efficient signature verification operations</li>
<li><strong>Quantum Resistance</strong>: Security against quantum cryptanalysis</li>
<li><strong>NIST Finalist</strong>: Round 3 finalist in NIST post-quantum standardization</li>
</ul>
<h2 id="security-levels-2"><a class="header" href="#security-levels-2">Security Levels</a></h2>
<p>Cypheron Core implements two Falcon variants:</p>
<div class="table-wrapper"><table><thead><tr><th>Variant</th><th>Security Level</th><th>Public Key</th><th>Secret Key</th><th>Signature</th></tr></thead><tbody>
<tr><td>Falcon-512</td><td>Level 1 (~112-bit)</td><td>897 bytes</td><td>1,281 bytes</td><td>~666 bytes</td></tr>
<tr><td>Falcon-1024</td><td>Level 5 (~256-bit)</td><td>1,793 bytes</td><td>2,305 bytes</td><td>~1,280 bytes</td></tr>
</tbody></table>
</div>
<p><em>Note: Falcon signatures have variable length; sizes shown are typical values.</em></p>
<h2 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h2>
<h3 id="key-generation-2"><a class="header" href="#key-generation-2">Key Generation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::sig::{Falcon512, DigitalSignature};

// Generate a new keypair
let (public_key, secret_key) = Falcon512::keypair()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="message-signing-1"><a class="header" href="#message-signing-1">Message Signing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let message = b"Falcon signature example";

// Sign the message
let signature = Falcon512::sign(&amp;secret_key, message)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="signature-verification-1"><a class="header" href="#signature-verification-1">Signature Verification</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Verify the signature
let is_valid = Falcon512::verify(&amp;public_key, message, &amp;signature)?;
assert!(is_valid);
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-usage-1"><a class="header" href="#advanced-usage-1">Advanced Usage</a></h2>
<h3 id="deterministic-key-generation-1"><a class="header" href="#deterministic-key-generation-1">Deterministic Key Generation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::sig::Falcon512;

// Generate keypair from seed (for testing)
let seed = [1u8; 48];  // Falcon uses 48-byte seeds
let (pk, sk) = Falcon512::keypair_deterministic(&amp;seed)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="variable-length-signatures"><a class="header" href="#variable-length-signatures">Variable-Length Signatures</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Falcon signatures have variable length
let signature = Falcon512::sign(&amp;secret_key, message)?;
println!("Signature length: {} bytes", signature.len());

// Length varies based on randomness and message
// Typical range: 600-700 bytes for Falcon-512
<span class="boring">}</span></code></pre></pre>
<h2 id="security-considerations-2"><a class="header" href="#security-considerations-2">Security Considerations</a></h2>
<h3 id="recommended-usage-1"><a class="header" href="#recommended-usage-1">Recommended Usage</a></h3>
<ul>
<li><strong>Use Falcon-512</strong> for applications requiring compact signatures</li>
<li><strong>Use Falcon-1024</strong> for high-security applications needing 256-bit security</li>
<li>Consider ML-DSA for applications where deterministic signature size is important</li>
</ul>
<h3 id="key-security"><a class="header" href="#key-security">Key Security</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use secrecy::{ExposeSecret, Zeroize};

// Secret keys are automatically zeroized
impl Drop for FalconSecretKey {
    fn drop(&amp;mut self) {
        self.0.zeroize();
    }
}

// Safe secret key access
secret_key.expose_secret(|key_bytes| {
    Falcon512::sign_with_raw_key(key_bytes, message)
})
<span class="boring">}</span></code></pre></pre>
<h3 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h3>
<ul>
<li>Uses floating-point arithmetic internally (NTRU structure)</li>
<li>Signature generation involves random sampling</li>
<li>Verification is deterministic and constant-time</li>
</ul>
<h2 id="performance-characteristics-2"><a class="header" href="#performance-characteristics-2">Performance Characteristics</a></h2>
<h3 id="typical-performance-x86_64-30-ghz-1"><a class="header" href="#typical-performance-x86_64-30-ghz-1">Typical Performance (x86_64, 3.0 GHz)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Falcon-512</th><th>Falcon-1024</th></tr></thead><tbody>
<tr><td>Key Generation</td><td>~2.5ms</td><td>~8ms</td></tr>
<tr><td>Sign</td><td>~1.2ms</td><td>~3.5ms</td></tr>
<tr><td>Verify</td><td>~85μs</td><td>~180μs</td></tr>
</tbody></table>
</div>
<h3 id="memory-usage-1"><a class="header" href="#memory-usage-1">Memory Usage</a></h3>
<ul>
<li>Key generation requires temporary working memory</li>
<li>Signing uses stack-allocated buffers</li>
<li>Verification is memory-efficient</li>
</ul>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<h3 id="common-errors-1"><a class="header" href="#common-errors-1">Common Errors</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::error::Error;

match Falcon512::verify(&amp;public_key, message, &amp;signature) {
    Ok(true) =&gt; println!("Valid signature"),
    Ok(false) =&gt; println!("Invalid signature"), 
    Err(Error::InvalidPublicKey) =&gt; println!("Malformed public key"),
    Err(Error::InvalidSignature) =&gt; println!("Malformed signature"),
    Err(Error::SigningFailed) =&gt; println!("Random sampling failed"),
    Err(e) =&gt; println!("Other error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="input-validation-1"><a class="header" href="#input-validation-1">Input Validation</a></h3>
<ul>
<li>Public keys validated for proper NTRU structure</li>
<li>Signatures validated for encoding compliance</li>
<li>Invalid inputs return errors without panicking</li>
</ul>
<h2 id="interoperability-1"><a class="header" href="#interoperability-1">Interoperability</a></h2>
<h3 id="nist-compatibility"><a class="header" href="#nist-compatibility">NIST Compatibility</a></h3>
<ul>
<li>Implements NIST Round 3 Falcon specification</li>
<li>Compatible with reference implementations</li>
<li>Passes all official test vectors</li>
</ul>
<h3 id="serialization-1"><a class="header" href="#serialization-1">Serialization</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Serialize keys and signatures
let pk_bytes = public_key.as_bytes();
let sk_bytes = secret_key.expose_secret(|bytes| bytes.to_vec());
let sig_bytes = signature.as_bytes();

// Deserialize from bytes
let public_key = FalconPublicKey::from_bytes(&amp;pk_bytes)?;
let signature = FalconSignature::from_bytes(&amp;sig_bytes)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="comparison-with-other-schemes"><a class="header" href="#comparison-with-other-schemes">Comparison with Other Schemes</a></h2>
<h3 id="falcon-vs-ml-dsa"><a class="header" href="#falcon-vs-ml-dsa">Falcon vs ML-DSA</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Falcon</th><th>ML-DSA</th></tr></thead><tbody>
<tr><td>Signature Size</td><td>Smaller (~666 bytes)</td><td>Larger (~2,420+ bytes)</td></tr>
<tr><td>Key Generation</td><td>Slower</td><td>Faster</td></tr>
<tr><td>Verification</td><td>Fast</td><td>Fast</td></tr>
<tr><td>Implementation</td><td>More complex</td><td>Simpler</td></tr>
<tr><td>Standardization</td><td>NIST Round 3 finalist</td><td>NIST standardized</td></tr>
</tbody></table>
</div>
<h3 id="use-case-recommendations"><a class="header" href="#use-case-recommendations">Use Case Recommendations</a></h3>
<ul>
<li><strong>Choose Falcon</strong> when signature size is critical</li>
<li><strong>Choose ML-DSA</strong> for standardized compliance</li>
<li><strong>Consider SPHINCS+</strong> for hash-based security model</li>
</ul>
<h2 id="hybrid-usage"><a class="header" href="#hybrid-usage">Hybrid Usage</a></h2>
<p>Falcon can be combined with classical signatures:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::hybrid::EccFalcon;

// Hybrid ECDSA + Falcon signature
let (hybrid_pk, hybrid_sk) = EccFalcon::keypair()?;
let hybrid_sig = EccFalcon::sign(&amp;hybrid_sk, message)?;
let is_valid = EccFalcon::verify(&amp;hybrid_pk, message, &amp;hybrid_sig)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="ntru-lattice-structure"><a class="header" href="#ntru-lattice-structure">NTRU Lattice Structure</a></h3>
<ul>
<li>Based on polynomial rings over NTRU lattices</li>
<li>Uses Gaussian sampling for signature generation</li>
<li>Rejection sampling ensures security properties</li>
</ul>
<h3 id="floating-point-considerations"><a class="header" href="#floating-point-considerations">Floating-Point Considerations</a></h3>
<ul>
<li>Implementation uses controlled floating-point arithmetic</li>
<li>Results are deterministic across platforms</li>
<li>Special handling for edge cases and rounding</li>
</ul>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<ul>
<li><a href="algorithms/ml-dsa.html">ML-DSA Digital Signatures</a> - NIST-standardized alternative</li>
<li><a href="algorithms/sphincsplus.html">SPHINCS+ Digital Signatures</a> - Hash-based signatures</li>
<li><a href="algorithms/../hybrid/overview.html">Hybrid Cryptography</a> - Combining schemes</li>
<li><a href="algorithms/../security/model.html">Security Model</a> - Security considerations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sphincs-digital-signatures"><a class="header" href="#sphincs-digital-signatures">SPHINCS+ (Digital Signatures)</a></h1>
<p>SPHINCS+ is a hash-based post-quantum digital signature scheme offering conservative security assumptions and no reliance on algebraic problems.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>SPHINCS+ provides:</p>
<ul>
<li><strong>Conservative Security</strong>: Based only on hash function security</li>
<li><strong>No Algebraic Assumptions</strong>: Unlike lattice-based schemes</li>
<li><strong>Stateless Operation</strong>: No state management required</li>
<li><strong>Multiple Variants</strong>: Different security/performance tradeoffs</li>
</ul>
<h2 id="security-model"><a class="header" href="#security-model">Security Model</a></h2>
<p>SPHINCS+ security relies solely on:</p>
<ul>
<li><strong>Hash Function Security</strong>: SHA-256 or SHAKE-256 collision resistance</li>
<li><strong>No Quantum Vulnerability</strong>: Hash functions remain secure against quantum attacks</li>
<li><strong>Proven Reduction</strong>: Security reduces to underlying hash function</li>
</ul>
<h2 id="parameter-sets"><a class="header" href="#parameter-sets">Parameter Sets</a></h2>
<p>Cypheron Core implements multiple SPHINCS+ variants:</p>
<h3 id="sphincs-sha256-variants"><a class="header" href="#sphincs-sha256-variants">SPHINCS+-SHA256 Variants</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Variant</th><th>Security Level</th><th>Public Key</th><th>Secret Key</th><th>Signature</th></tr></thead><tbody>
<tr><td>sphincs-sha256-128s</td><td>Level 1 (small sig)</td><td>32 bytes</td><td>64 bytes</td><td>7,856 bytes</td></tr>
<tr><td>sphincs-sha256-128f</td><td>Level 1 (fast)</td><td>32 bytes</td><td>64 bytes</td><td>17,088 bytes</td></tr>
<tr><td>sphincs-sha256-192s</td><td>Level 3 (small sig)</td><td>48 bytes</td><td>96 bytes</td><td>16,224 bytes</td></tr>
<tr><td>sphincs-sha256-192f</td><td>Level 3 (fast)</td><td>48 bytes</td><td>96 bytes</td><td>35,664 bytes</td></tr>
<tr><td>sphincs-sha256-256s</td><td>Level 5 (small sig)</td><td>64 bytes</td><td>128 bytes</td><td>29,792 bytes</td></tr>
<tr><td>sphincs-sha256-256f</td><td>Level 5 (fast)</td><td>64 bytes</td><td>128 bytes</td><td>49,856 bytes</td></tr>
</tbody></table>
</div>
<h3 id="sphincs-shake256-variants"><a class="header" href="#sphincs-shake256-variants">SPHINCS+-SHAKE256 Variants</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Variant</th><th>Security Level</th><th>Public Key</th><th>Secret Key</th><th>Signature</th></tr></thead><tbody>
<tr><td>sphincs-shake256-128s</td><td>Level 1 (small sig)</td><td>32 bytes</td><td>64 bytes</td><td>7,856 bytes</td></tr>
<tr><td>sphincs-shake256-128f</td><td>Level 1 (fast)</td><td>32 bytes</td><td>64 bytes</td><td>17,088 bytes</td></tr>
<tr><td>sphincs-shake256-192s</td><td>Level 3 (small sig)</td><td>48 bytes</td><td>96 bytes</td><td>16,224 bytes</td></tr>
<tr><td>sphincs-shake256-192f</td><td>Level 3 (fast)</td><td>48 bytes</td><td>96 bytes</td><td>35,664 bytes</td></tr>
<tr><td>sphincs-shake256-256s</td><td>Level 5 (small sig)</td><td>64 bytes</td><td>128 bytes</td><td>29,792 bytes</td></tr>
<tr><td>sphincs-shake256-256f</td><td>Level 5 (fast)</td><td>64 bytes</td><td>128 bytes</td><td>49,856 bytes</td></tr>
</tbody></table>
</div>
<h2 id="basic-usage-3"><a class="header" href="#basic-usage-3">Basic Usage</a></h2>
<h3 id="key-generation-3"><a class="header" href="#key-generation-3">Key Generation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::sig::{SphincsPlusSha256128s, DigitalSignature};

// Generate a new keypair
let (public_key, secret_key) = SphincsPlusSha256128s::keypair()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="message-signing-2"><a class="header" href="#message-signing-2">Message Signing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let message = b"SPHINCS+ hash-based signature";

// Sign the message
let signature = SphincsPlusSha256128s::sign(&amp;secret_key, message)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="signature-verification-2"><a class="header" href="#signature-verification-2">Signature Verification</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Verify the signature
let is_valid = SphincsPlusSha256128s::verify(&amp;public_key, message, &amp;signature)?;
assert!(is_valid);
<span class="boring">}</span></code></pre></pre>
<h2 id="variant-selection"><a class="header" href="#variant-selection">Variant Selection</a></h2>
<h3 id="small-vs-fast-variants"><a class="header" href="#small-vs-fast-variants">Small vs Fast Variants</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::sig::{SphincsPlusSha256128s, SphincsPlusSha256128f};

// Small signature variant (slower, smaller signatures)
let (pk_s, sk_s) = SphincsPlusSha256128s::keypair()?;
let sig_s = SphincsPlusSha256128s::sign(&amp;sk_s, message)?;
println!("Small signature: {} bytes", sig_s.len());

// Fast variant (faster, larger signatures)  
let (pk_f, sk_f) = SphincsPlusSha256128f::keypair()?;
let sig_f = SphincsPlusSha256128f::sign(&amp;sk_f, message)?;
println!("Fast signature: {} bytes", sig_f.len());
<span class="boring">}</span></code></pre></pre>
<h3 id="sha-256-vs-shake-256"><a class="header" href="#sha-256-vs-shake-256">SHA-256 vs SHAKE-256</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::sig::{SphincsPlusSha256128s, SphincsPlusShake256128s};

// SHA-256 based variant
let (pk_sha, sk_sha) = SphincsPlusSha256128s::keypair()?;

// SHAKE-256 based variant
let (pk_shake, sk_shake) = SphincsPlusShake256128s::keypair()?;

// Both provide equivalent security, choose based on:
// - SHA-256: Wider acceptance, NIST standard
// - SHAKE-256: More flexible, part of SHA-3 family
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-usage-2"><a class="header" href="#advanced-usage-2">Advanced Usage</a></h2>
<h3 id="deterministic-key-generation-2"><a class="header" href="#deterministic-key-generation-2">Deterministic Key Generation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::sig::SphincsPlusSha256128s;

// Generate keypair from seed
let seed = [0u8; 48];  // SPHINCS+ uses variable seed lengths
let (pk, sk) = SphincsPlusSha256128s::keypair_deterministic(&amp;seed)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="context-separation-1"><a class="header" href="#context-separation-1">Context Separation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sign with context for domain separation
let context = b"document-signing-v2";
let signature = SphincsPlusSha256128s::sign_with_context(&amp;secret_key, message, context)?;
let is_valid = SphincsPlusSha256128s::verify_with_context(&amp;public_key, message, &amp;signature, context)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="security-considerations-3"><a class="header" href="#security-considerations-3">Security Considerations</a></h2>
<h3 id="conservative-security-model"><a class="header" href="#conservative-security-model">Conservative Security Model</a></h3>
<ul>
<li><strong>No Algebraic Assumptions</strong>: Security doesn’t depend on lattice problems</li>
<li><strong>Post-Quantum Safe</strong>: Hash functions remain secure against quantum computers</li>
<li><strong>Proven Security</strong>: Well-understood cryptographic foundations</li>
</ul>
<h3 id="recommended-usage-2"><a class="header" href="#recommended-usage-2">Recommended Usage</a></h3>
<ul>
<li><strong>Use 128s variants</strong> for applications requiring smaller signatures</li>
<li><strong>Use 128f variants</strong> for applications requiring faster signing</li>
<li><strong>Use 192s/256s</strong> for higher security requirements</li>
<li><strong>Choose SHA-256</strong> for maximum compatibility</li>
</ul>
<h3 id="key-management-1"><a class="header" href="#key-management-1">Key Management</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use secrecy::{ExposeSecret, Zeroize};

// Secret keys automatically zeroized on drop
impl Drop for SphincsSecretKey {
    fn drop(&amp;mut self) {
        self.0.zeroize();
    }
}

// Safe secret key access
secret_key.expose_secret(|key_bytes| {
    SphincsPlusSha256128s::sign_with_raw_key(key_bytes, message)
})
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-characteristics-3"><a class="header" href="#performance-characteristics-3">Performance Characteristics</a></h2>
<h3 id="typical-performance-x86_64-30-ghz-2"><a class="header" href="#typical-performance-x86_64-30-ghz-2">Typical Performance (x86_64, 3.0 GHz)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Variant</th><th>Key Generation</th><th>Sign</th><th>Verify</th></tr></thead><tbody>
<tr><td>sha256-128s</td><td>~15ms</td><td>~180ms</td><td>~4ms</td></tr>
<tr><td>sha256-128f</td><td>~15ms</td><td>~8ms</td><td>~2ms</td></tr>
<tr><td>sha256-192s</td><td>~25ms</td><td>~650ms</td><td>~8ms</td></tr>
<tr><td>sha256-192f</td><td>~25ms</td><td>~18ms</td><td>~4ms</td></tr>
<tr><td>sha256-256s</td><td>~35ms</td><td>~1.2s</td><td>~12ms</td></tr>
<tr><td>sha256-256f</td><td>~35ms</td><td>~35ms</td><td>~6ms</td></tr>
</tbody></table>
</div>
<h3 id="memory-usage-2"><a class="header" href="#memory-usage-2">Memory Usage</a></h3>
<ul>
<li>Small key sizes (32-128 bytes)</li>
<li>Large signature sizes (7KB-50KB)</li>
<li>Stack-based operations, no heap allocation</li>
</ul>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<h3 id="common-errors-2"><a class="header" href="#common-errors-2">Common Errors</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::error::Error;

match SphincsPlusSha256128s::verify(&amp;public_key, message, &amp;signature) {
    Ok(true) =&gt; println!("Valid signature"),
    Ok(false) =&gt; println!("Invalid signature"),
    Err(Error::InvalidPublicKey) =&gt; println!("Malformed public key"),
    Err(Error::InvalidSignature) =&gt; println!("Malformed signature"),
    Err(Error::HashingFailed) =&gt; println!("Internal hash computation failed"),
    Err(e) =&gt; println!("Other error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interoperability-2"><a class="header" href="#interoperability-2">Interoperability</a></h2>
<h3 id="nist-compliance-1"><a class="header" href="#nist-compliance-1">NIST Compliance</a></h3>
<ul>
<li>Implements NIST Round 3 SPHINCS+ specification</li>
<li>Compatible with reference implementations</li>
<li>Passes all official test vectors</li>
</ul>
<h3 id="serialization-2"><a class="header" href="#serialization-2">Serialization</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Serialize keys and signatures
let pk_bytes = public_key.as_bytes();
let sk_bytes = secret_key.expose_secret(|bytes| bytes.to_vec());
let sig_bytes = signature.as_bytes();

// Deserialize from bytes
let public_key = SphincsPublicKey::from_bytes(&amp;pk_bytes)?;
let signature = SphincsSignature::from_bytes(&amp;sig_bytes)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="comparison-with-other-schemes-1"><a class="header" href="#comparison-with-other-schemes-1">Comparison with Other Schemes</a></h2>
<h3 id="sphincs-vs-lattice-based-schemes"><a class="header" href="#sphincs-vs-lattice-based-schemes">SPHINCS+ vs Lattice-Based Schemes</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>SPHINCS+</th><th>ML-DSA/Falcon</th></tr></thead><tbody>
<tr><td>Security Model</td><td>Hash functions only</td><td>Lattice problems</td></tr>
<tr><td>Signature Size</td><td>Large (7KB-50KB)</td><td>Small (0.7KB-4KB)</td></tr>
<tr><td>Key Size</td><td>Small (32-128 bytes)</td><td>Medium (1-3KB)</td></tr>
<tr><td>Speed</td><td>Slower</td><td>Faster</td></tr>
<tr><td>Quantum Resistance</td><td>Very conservative</td><td>Well-studied</td></tr>
</tbody></table>
</div>
<h3 id="use-case-recommendations-1"><a class="header" href="#use-case-recommendations-1">Use Case Recommendations</a></h3>
<ul>
<li><strong>Choose SPHINCS+</strong> for maximum conservative security</li>
<li><strong>Choose ML-DSA</strong> for practical performance and NIST standardization</li>
<li><strong>Choose Falcon</strong> for compact signatures</li>
<li><strong>Consider hybrid</strong> for transition periods</li>
</ul>
<h2 id="hybrid-usage-1"><a class="header" href="#hybrid-usage-1">Hybrid Usage</a></h2>
<p>SPHINCS+ can be combined with other schemes:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::hybrid::EccSphincs;

// Hybrid ECDSA + SPHINCS+ signature
let (hybrid_pk, hybrid_sk) = EccSphincs::keypair()?;
let hybrid_sig = EccSphincs::sign(&amp;hybrid_sk, message)?;
let is_valid = EccSphincs::verify(&amp;hybrid_pk, message, &amp;hybrid_sig)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="implementation-details-1"><a class="header" href="#implementation-details-1">Implementation Details</a></h2>
<h3 id="hash-based-construction"><a class="header" href="#hash-based-construction">Hash-Based Construction</a></h3>
<ul>
<li>Built on one-way hash functions and Merkle trees</li>
<li>Uses WOTS+ (Winternitz One-Time Signature Plus)</li>
<li>XMSS-style tree authentication</li>
<li>No state management required (stateless)</li>
</ul>
<h3 id="parameter-selection"><a class="header" href="#parameter-selection">Parameter Selection</a></h3>
<ul>
<li><strong>“s” variants</strong>: Optimize for smaller signatures</li>
<li><strong>“f” variants</strong>: Optimize for faster operations</li>
<li><strong>Security levels</strong>: 128, 192, 256-bit equivalent security</li>
<li><strong>Hash functions</strong>: SHA-256 or SHAKE-256</li>
</ul>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See Also</a></h2>
<ul>
<li><a href="algorithms/ml-dsa.html">ML-DSA Digital Signatures</a> - Lattice-based alternative</li>
<li><a href="algorithms/falcon.html">Falcon Digital Signatures</a> - Compact lattice-based signatures</li>
<li><a href="algorithms/../hybrid/overview.html">Hybrid Cryptography</a> - Combining schemes</li>
<li><a href="algorithms/../security/model.html">Security Model</a> - Security considerations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hybrid-cryptography-overview"><a class="header" href="#hybrid-cryptography-overview">Hybrid Cryptography Overview</a></h1>
<p>Hybrid cryptography combines classical and post-quantum algorithms to provide defense against both current and future cryptographic attacks.</p>
<h2 id="why-hybrid"><a class="header" href="#why-hybrid">Why Hybrid?</a></h2>
<p>Hybrid schemes provide multiple layers of security:</p>
<ol>
<li><strong>Classical Security</strong>: Protection against traditional computing threats</li>
<li><strong>Quantum Resistance</strong>: Protection against quantum computer attacks</li>
<li><strong>Migration Safety</strong>: Smooth transition from classical to post-quantum</li>
<li><strong>Defense in Depth</strong>: Multiple independent security assumptions</li>
</ol>
<h2 id="hybrid-strategies"><a class="header" href="#hybrid-strategies">Hybrid Strategies</a></h2>
<h3 id="composite-signatures"><a class="header" href="#composite-signatures">Composite Signatures</a></h3>
<p>Combine classical and post-quantum signature schemes:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::hybrid::{EccDilithium, HybridEngine};

// Generate hybrid keypair (ECC + ML-DSA)
let (public_key, secret_key) = EccDilithium::keypair()?;

// Create composite signature  
let message = b"Hybrid signed message";
let signature = EccDilithium::sign(message, &amp;secret_key)?;

// Verification can use different policies
let is_valid = EccDilithium::verify(message, &amp;signature, &amp;public_key);
<span class="boring">}</span></code></pre></pre>
<h3 id="verification-policies"><a class="header" href="#verification-policies">Verification Policies</a></h3>
<p>Different policies for signature verification:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::hybrid::VerificationPolicy;

// Strict: Both signatures must be valid
let strict_valid = EccDilithium::verify_with_policy(
    message,
    &amp;signature, 
    &amp;public_key,
    VerificationPolicy::BothRequired
);

// Relaxed: Either signature can be valid
let relaxed_valid = EccDilithium::verify_with_policy(
    message,
    &amp;signature,
    &amp;public_key, 
    VerificationPolicy::EitherValid
);

// Migration: Prefer post-quantum but accept classical
let migration_valid = EccDilithium::verify_with_policy(
    message,
    &amp;signature,
    &amp;public_key,
    VerificationPolicy::PostQuantumPreferred
);
<span class="boring">}</span></code></pre></pre>
<h2 id="security-analysis"><a class="header" href="#security-analysis">Security Analysis</a></h2>
<h3 id="combined-security-level"><a class="header" href="#combined-security-level">Combined Security Level</a></h3>
<p>The security of hybrid schemes depends on verification policy:</p>
<div class="table-wrapper"><table><thead><tr><th>Policy</th><th>Security Level</th><th>Description</th></tr></thead><tbody>
<tr><td>BothRequired</td><td>min(classical, pq)</td><td>Weakest component determines security</td></tr>
<tr><td>EitherValid</td><td>max(classical, pq)</td><td>Strongest component determines security</td></tr>
<tr><td>PostQuantumPreferred</td><td>post-quantum</td><td>Prioritizes quantum resistance</td></tr>
</tbody></table>
</div>
<h3 id="attack-scenarios"><a class="header" href="#attack-scenarios">Attack Scenarios</a></h3>
<p><strong>Quantum Computer Attack:</strong></p>
<ul>
<li>Classical component: Broken</li>
<li>Post-quantum component: Secure</li>
<li>Result with EitherValid: Secure</li>
</ul>
<p><strong>Classical Cryptanalysis:</strong></p>
<ul>
<li>Classical component: Potentially broken</li>
<li>Post-quantum component: Secure</li>
<li>Result with EitherValid: Secure</li>
</ul>
<p><strong>Post-Quantum Cryptanalysis:</strong></p>
<ul>
<li>Classical component: Secure</li>
<li>Post-quantum component: Potentially broken</li>
<li>Result with EitherValid: Secure</li>
</ul>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="signature-size"><a class="header" href="#signature-size">Signature Size</a></h3>
<p>Hybrid signatures combine both signature types:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Individual signature sizes (approximate)
// ECDSA P-256: ~64 bytes
// ML-DSA-65: ~3300 bytes  
// Combined: ~3364 bytes

let (pk, sk) = EccDilithium::keypair()?;
let signature = EccDilithium::sign(b"message", &amp;sk)?;

println!("Hybrid signature size: {} bytes", signature.len());
// Output: Hybrid signature size: 3364 bytes
<span class="boring">}</span></code></pre></pre>
<h3 id="verification-time"><a class="header" href="#verification-time">Verification Time</a></h3>
<p>Verification involves both algorithms:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;

let start = Instant::now();
let valid = EccDilithium::verify(message, &amp;signature, &amp;public_key);
let duration = start.elapsed();

println!("Hybrid verification: {:?}", duration);
// Typical: ~0.5ms (classical) + ~0.1ms (post-quantum) = ~0.6ms
<span class="boring">}</span></code></pre></pre>
<h2 id="migration-strategies"><a class="header" href="#migration-strategies">Migration Strategies</a></h2>
<h3 id="phase-1-introduction"><a class="header" href="#phase-1-introduction">Phase 1: Introduction</a></h3>
<p>Start with relaxed verification policy:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Accept either classical or post-quantum signatures
let valid = EccDilithium::verify_with_policy(
    message,
    &amp;signature,
    &amp;public_key,
    VerificationPolicy::EitherValid
);
<span class="boring">}</span></code></pre></pre>
<h3 id="phase-2-transition"><a class="header" href="#phase-2-transition">Phase 2: Transition</a></h3>
<p>Require both signatures but log failures:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let strict_valid = EccDilithium::verify_with_policy(
    message,
    &amp;signature,
    &amp;public_key,
    VerificationPolicy::BothRequired
);

if !strict_valid {
    // Log for monitoring but continue processing
    log::warn!("Hybrid signature verification failed");
    
    // Fallback to relaxed policy during transition
    let relaxed_valid = EccDilithium::verify_with_policy(
        message,
        &amp;signature,
        &amp;public_key,
        VerificationPolicy::EitherValid
    );
    
    return relaxed_valid;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="phase-3-post-quantum-only"><a class="header" href="#phase-3-post-quantum-only">Phase 3: Post-Quantum Only</a></h3>
<p>Eventually migrate to pure post-quantum:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::sig::{MlDsa65, SignatureEngine};

// Pure post-quantum signatures
let (pk, sk) = MlDsa65::keypair()?;
let signature = MlDsa65::sign(message, &amp;sk)?;
let valid = MlDsa65::verify(message, &amp;signature, &amp;pk);
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-management"><a class="header" href="#configuration-management">Configuration Management</a></h2>
<h3 id="policy-configuration"><a class="header" href="#policy-configuration">Policy Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub struct HybridConfig {
    pub verification_policy: VerificationPolicy,
    pub signature_format: SignatureFormat,
    pub key_rotation_interval: u64, // days
}

impl Default for HybridConfig {
    fn default() -&gt; Self {
        Self {
            verification_policy: VerificationPolicy::EitherValid,
            signature_format: SignatureFormat::Concatenated,
            key_rotation_interval: 90,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="environment-based-configuration"><a class="header" href="#environment-based-configuration">Environment-Based Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;

fn get_verification_policy() -&gt; VerificationPolicy {
    match env::var("CYPHERON_VERIFICATION_POLICY").as_deref() {
        Ok("strict") =&gt; VerificationPolicy::BothRequired,
        Ok("relaxed") =&gt; VerificationPolicy::EitherValid,
        Ok("pq-preferred") =&gt; VerificationPolicy::PostQuantumPreferred,
        _ =&gt; VerificationPolicy::EitherValid, // Default
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interoperability-3"><a class="header" href="#interoperability-3">Interoperability</a></h2>
<h3 id="wire-format"><a class="header" href="#wire-format">Wire Format</a></h3>
<p>Hybrid signatures can use different encoding formats:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Concatenated format: [classical_sig][pq_sig]
// Tagged format: [tag][len][classical_sig][tag][len][pq_sig]
// ASN.1 format: Structured encoding with OIDs
<span class="boring">}</span></code></pre></pre>
<h3 id="protocol-integration"><a class="header" href="#protocol-integration">Protocol Integration</a></h3>
<p>Example integration with TLS:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Custom signature scheme identifier
const HYBRID_ECC_MLDSA: u16 = 0xFE00;

impl SignatureScheme for EccDilithium {
    fn scheme_id(&amp;self) -&gt; u16 {
        HYBRID_ECC_MLDSA
    }
    
    fn sign(&amp;self, message: &amp;[u8], key: &amp;PrivateKey) -&gt; Vec&lt;u8&gt; {
        // Convert from TLS types to Cypheron types
        let sk = HybridSecretKey::from_tls(key);
        EccDilithium::sign(message, &amp;sk).unwrap()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See Also</a></h2>
<ul>
<li><a href="hybrid/ecc-mldsa.html">ECC + ML-DSA</a> - Specific hybrid implementation</li>
<li><a href="hybrid/hybrid-kem.html">Hybrid KEM</a> - Key encapsulation mechanisms</li>
<li><a href="hybrid/security.html">Security Considerations</a> - Security analysis</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-types"><a class="header" href="#core-types">Core Types</a></h1>
<p>This section documents the core types and data structures used throughout Cypheron Core.</p>
<h2 id="key-types"><a class="header" href="#key-types">Key Types</a></h2>
<h3 id="public-keys"><a class="header" href="#public-keys">Public Keys</a></h3>
<p>All public key types are <code>Clone</code> and can be safely shared:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::MlKemPublicKey;
use cypheron_core::sig::MlDsaPublicKey;

// ML-KEM public keys
let pk: MlKemPublicKey = // ... from keypair generation
let pk_clone = pk.clone(); // Safe to clone

// ML-DSA public keys  
let verify_key: MlDsaPublicKey = // ... from keypair generation
<span class="boring">}</span></code></pre></pre>
<h3 id="secret-keys"><a class="header" href="#secret-keys">Secret Keys</a></h3>
<p>Secret keys are wrapped in <code>SecretBox</code> for memory safety:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::MlKemSecretKey;
use cypheron_core::sig::MlDsaSecretKey;
use secrecy::ExposeSecret;

// Secret keys are automatically zeroized when dropped
let sk: MlKemSecretKey = // ... from keypair generation

// Access secret data only when needed
let secret_bytes = sk.0.expose_secret();
// sk is automatically zeroized when it goes out of scope
<span class="boring">}</span></code></pre></pre>
<h2 id="shared-secrets"><a class="header" href="#shared-secrets">Shared Secrets</a></h2>
<p>Shared secrets from KEM operations are securely managed:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::{MlKem768, Kem};
use secrecy::ExposeSecret;

let (pk, sk) = MlKem768::keypair()?;
let (ct, shared_secret) = MlKem768::encapsulate(&amp;pk)?;

// Access shared secret data
let secret_data = shared_secret.expose_secret(); // &amp;[u8; 32]

// shared_secret is zeroized when dropped
<span class="boring">}</span></code></pre></pre>
<h2 id="error-types"><a class="header" href="#error-types">Error Types</a></h2>
<h3 id="kem-errors"><a class="header" href="#kem-errors">KEM Errors</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::MlKemError;

pub enum MlKemError {
    KeyGenerationEntropyFailure,
    KeyGenerationInternalError,
    EncapsulationInvalidKey,
    EncapsulationInternalError,
    DecapsulationInvalidCiphertext,
    DecapsulationInternalError,
    InvalidCiphertextLength { expected: usize, actual: usize },
    InvalidPublicKeyLength { expected: usize, actual: usize },
    InvalidSecretKeyLength { expected: usize, actual: usize },
    CLibraryError { code: i32 },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="signature-errors"><a class="header" href="#signature-errors">Signature Errors</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::sig::MlDsaError;

pub enum MlDsaError {
    KeyGenerationFailed,
    SignatureFailed,
    VerificationFailed,
    InvalidSignatureLength { expected: usize, actual: usize },
    InvalidPublicKeyLength { expected: usize, actual: usize },
    InvalidSecretKeyLength { expected: usize, actual: usize },
    CLibraryError { code: i32 },
}
<span class="boring">}</span></code></pre></pre>
<h2 id="trait-definitions"><a class="header" href="#trait-definitions">Trait Definitions</a></h2>
<h3 id="kem-trait"><a class="header" href="#kem-trait">KEM Trait</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Kem {
    type PublicKey;
    type SecretKey;
    type Ciphertext;
    type SharedSecret;
    type Error;

    fn keypair() -&gt; Result&lt;(Self::PublicKey, Self::SecretKey), Self::Error&gt;;
    fn encapsulate(pk: &amp;Self::PublicKey) -&gt; Result&lt;(Self::Ciphertext, Self::SharedSecret), Self::Error&gt;;
    fn decapsulate(ct: &amp;Self::Ciphertext, sk: &amp;Self::SecretKey) -&gt; Result&lt;Self::SharedSecret, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="signatureengine-trait"><a class="header" href="#signatureengine-trait">SignatureEngine Trait</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait SignatureEngine {
    type PublicKey;
    type SecretKey;
    type Signature;
    type Error;

    fn keypair() -&gt; Result&lt;(Self::PublicKey, Self::SecretKey), Self::Error&gt;;
    fn sign(message: &amp;[u8], sk: &amp;Self::SecretKey) -&gt; Result&lt;Self::Signature, Self::Error&gt;;
    fn verify(message: &amp;[u8], signature: &amp;Self::Signature, pk: &amp;Self::PublicKey) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="size-constants"><a class="header" href="#size-constants">Size Constants</a></h2>
<p>All algorithm parameters are available as constants:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::sizes;
use cypheron_core::sig::sizes as sig_sizes;

// ML-KEM sizes
const ML_KEM_768_PUBLIC: usize = sizes::ML_KEM_768_PUBLIC;     // 1184
const ML_KEM_768_SECRET: usize = sizes::ML_KEM_768_SECRET;     // 2400  
const ML_KEM_768_CIPHERTEXT: usize = sizes::ML_KEM_768_CIPHERTEXT; // 1088
const ML_KEM_768_SHARED: usize = sizes::ML_KEM_768_SHARED;     // 32

// ML-DSA sizes
const ML_DSA_65_PUBLIC: usize = sig_sizes::ML_DSA_65_PUBLIC;   // 1952
const ML_DSA_65_SECRET: usize = sig_sizes::ML_DSA_65_SECRET;   // 4032
<span class="boring">}</span></code></pre></pre>
<h2 id="memory-safety-guarantees"><a class="header" href="#memory-safety-guarantees">Memory Safety Guarantees</a></h2>
<h3 id="automatic-zeroization"><a class="header" href="#automatic-zeroization">Automatic Zeroization</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use zeroize::Zeroize;

// All secret types implement Zeroize
fn example() {
    let (pk, sk) = MlKem768::keypair().unwrap();
    
    // Use secret key...
    
} // sk is automatically zeroized here when dropped
<span class="boring">}</span></code></pre></pre>
<h3 id="secretbox-protection"><a class="header" href="#secretbox-protection">SecretBox Protection</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use secrecy::{SecretBox, ExposeSecret};

// Secret data is protected until explicitly exposed
let secret = SecretBox::new([1, 2, 3, 4]);

// Only expose when absolutely necessary
let data = secret.expose_secret(); // &amp;[u8]

// secret is zeroized when dropped
<span class="boring">}</span></code></pre></pre>
<h2 id="serialization-support"><a class="header" href="#serialization-support">Serialization Support</a></h2>
<p>With the <code>serialize</code> feature enabled:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct KeyPair {
    public_key: MlKemPublicKey,
    // Note: Secret keys should NOT be serialized in most cases
}

// Serialize public key safely
let json = serde_json::to_string(&amp;public_key)?;

// Deserialize public key  
let pk: MlKemPublicKey = serde_json::from_str(&amp;json)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<p>All public key types are <code>Send</code> and <code>Sync</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use std::thread;

let (pk, _sk) = MlKem768::keypair().unwrap();
let shared_pk = Arc::new(pk);

// Public keys can be shared across threads
let handles: Vec&lt;_&gt; = (0..4).map(|_| {
    let pk = shared_pk.clone();
    thread::spawn(move || {
        // Use pk in thread...
        MlKem768::encapsulate(&amp;pk)
    })
}).collect();
<span class="boring">}</span></code></pre></pre>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See Also</a></h2>
<ul>
<li><a href="api/kem.html">KEM Operations</a> - Key Encapsulation APIs</li>
<li><a href="api/signatures.html">Signature Operations</a> - Digital Signature APIs</li>
<li><a href="api/errors.html">Error Handling</a> - Error types and handling</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-architecture"><a class="header" href="#system-architecture">System Architecture</a></h1>
<p>This section provides an overview of Cypheron Core’s architecture and design principles.</p>
<p>For complete technical details, see the full <a href="architecture/../../ARCHITECTURE.html">Architecture Documentation</a>.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>Cypheron Core is structured as a multi-layered system combining Rust-native implementations with NIST reference implementations through FFI bindings. The architecture ensures cross-platform compatibility while maintaining security and performance.</p>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Module Path</th><th>Primary Types</th><th>Purpose</th></tr></thead><tbody>
<tr><td>ML-KEM(Kyber)</td><td><code>kem/</code></td><td><code>MlKem512</code>, <code>MlKem768</code>, <code>MlKem1024</code></td><td>Key encapsulation mechanisms</td></tr>
<tr><td>Digital Signatures</td><td><code>sig/</code></td><td><code>MlDsa44</code>, <code>MlDsa65</code>, <code>MlDsa87</code>, <code>Falcon512</code>, <code>Falcon1024</code></td><td>Post-quantum digital signatures</td></tr>
<tr><td>Hybrid Cryptography</td><td><code>hybrid/</code></td><td><code>P256mlKem768</code>, <code>EccDilithium</code>, <code>CompositeKeypair</code></td><td>Classical + PQ combinations</td></tr>
</tbody></table>
</div>
<h2 id="architecture-layers"><a class="header" href="#architecture-layers">Architecture Layers</a></h2>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                    APPLICATION LAYER                        │
│  • Safe Rust API                                           │  
│  • Type Safety Guaranteed                                   │
├─────────────────────────────────────────────────────────────┤
│                    CYPHERON CORE                            │
│  • Algorithm Wrappers                                       │
│  • Memory Management                                        │
│  • Error Handling                                           │
├═════════════════════════════════════════════════════════════┤
│                    FFI BOUNDARY                             │
│  • Input Validation                                         │
│  • Buffer Management                                        │
│  • Safety Enforcement                                       │
├═════════════════════════════════════════════════════════════┤
│                    NIST C IMPLEMENTATIONS                   │
│  • ML-KEM Reference Code                                    │
│  • ML-DSA Reference Code                                    │
│  • Falcon &amp; SPHINCS+ Code                                   │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="build-system-architecture"><a class="header" href="#build-system-architecture">Build System Architecture</a></h2>
<p>The build system orchestrates compilation of NIST reference implementations and generates FFI bindings:</p>
<ul>
<li><strong>Vendor Code Integrity</strong>: SHA-256 verification of all C source files</li>
<li><strong>Secure Compilation</strong>: Platform-specific optimization with security flags</li>
<li><strong>FFI Safety</strong>: Automated binding generation with function allowlisting</li>
</ul>
<h2 id="platform-abstraction-layer"><a class="header" href="#platform-abstraction-layer">Platform Abstraction Layer</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Secure Random</th><th>Memory Protection</th><th>Key Features</th></tr></thead><tbody>
<tr><td>Windows</td><td><code>BCryptGenRandom</code></td><td><code>VirtualProtect</code></td><td>BCrypt API, Windows Crypto</td></tr>
<tr><td>macOS</td><td><code>SecRandom</code></td><td><code>mprotect</code></td><td>Security Framework, Apple Silicon detection</td></tr>
<tr><td>Linux</td><td><code>getrandom</code> syscall</td><td><code>mprotect</code></td><td>Hardware RNG detection, CPU affinity</td></tr>
</tbody></table>
</div>
<h2 id="testing-and-validation"><a class="header" href="#testing-and-validation">Testing and Validation</a></h2>
<p>The testing infrastructure includes:</p>
<ol>
<li><strong>Known Answer Tests (KAT)</strong> - NIST compliance validation</li>
<li><strong>Property Based Testing</strong> - Cryptographic property verification</li>
<li><strong>Security Analysis</strong> - Timing attacks and memory safety</li>
<li><strong>Fuzzing Infrastructure</strong> - Robustness testing</li>
<li><strong>Performance Benchmarking</strong> - Regression detection</li>
</ol>
<p>For detailed technical architecture including security analysis, see the complete <a href="architecture/../../ARCHITECTURE.html">Architecture Documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-architecture"><a class="header" href="#security-architecture">Security Architecture</a></h1>
<p>Cypheron Core implements a comprehensive security architecture designed for post-quantum cryptographic applications requiring high assurance.</p>
<p>For complete security analysis, see the full <a href="architecture/../../ARCHITECTURE.html#security-architecture">Architecture Documentation</a>.</p>
<h2 id="security-architecture-diagram"><a class="header" href="#security-architecture-diagram">Security Architecture Diagram</a></h2>
<pre><code>┌─────────────────────────────────────────────────────────────────────────────┐
│                         CYPHERON CORE SECURITY ARCHITECTURE                 │
│ ┌─────────────────────────────────────────────────────────────────────────┐ │
│ │                        APPLICATION LAYER                                │ │
│ │  • Memory Safety: Rust Compiler Guaranteed                             │ │
│ │  • Security Level: FULLY TRUSTED                                       │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
│ ┌─────────────────────────────────────────────────────────────────────────┐ │
│ │                        CYPHERON CORE API                               │ │
│ │  • Input Validation &amp; Sanitization                                     │ │
│ │  • Secure Memory Management                                            │ │
│ │  • Error Handling &amp; Recovery                                           │ │
│ │  • Security Level: CONDITIONALLY TRUSTED                              │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
│ ┌═════════════════════════════════════════════════════════════════════════┐ │
│ ║                        FFI SECURITY BOUNDARY                           ║ │
│ ║  • Buffer Bounds Validation                                            ║ │
│ ║  • Type Safety Enforcement                                             ║ │
│ ║  • Memory Ownership Control                                            ║ │
│ ║  • Security Level: CRITICAL TRUST BOUNDARY                            ║ │
│ └═════════════════════════════════════════════════════════════════════════┘ │
│ ┌─────────────────────────────────────────────────────────────────────────┐ │
│ │                        NIST C IMPLEMENTATIONS                          │ │
│ │  • Cryptographic Operations                                            │ │
│ │  • Manual Memory Management                                            │ │
│ │  • Platform-Specific Optimizations                                     │ │
│ │  • Security Level: UNTRUSTED (VERIFIED BY TESTING)                    │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="trust-boundaries"><a class="header" href="#trust-boundaries">Trust Boundaries</a></h2>
<h3 id="fully-trusted-zone"><a class="header" href="#fully-trusted-zone">Fully Trusted Zone</a></h3>
<p><strong>Rust Application Code &amp; Core API</strong></p>
<ul>
<li>Type safety guaranteed by Rust compiler</li>
<li>Memory safety enforced automatically</li>
<li>Bounds checking on all array accesses</li>
</ul>
<h3 id="conditionally-trusted-zone"><a class="header" href="#conditionally-trusted-zone">Conditionally Trusted Zone</a></h3>
<p><strong>Cypheron Core Unsafe Wrappers</strong></p>
<ul>
<li>Input validation and sanitization</li>
<li>Buffer allocation and lifetime management</li>
<li>Error handling and conversion</li>
<li>Manual safety verification required</li>
</ul>
<h3 id="untrusted-zone"><a class="header" href="#untrusted-zone">Untrusted Zone</a></h3>
<p><strong>NIST C Reference Implementations</strong></p>
<ul>
<li>Manual memory management</li>
<li>Potential undefined behavior</li>
<li>Platform-specific behavior</li>
<li>Trust through verification and testing</li>
</ul>
<h2 id="security-properties"><a class="header" href="#security-properties">Security Properties</a></h2>
<h3 id="memory-safety-1"><a class="header" href="#memory-safety-1">Memory Safety</a></h3>
<ul>
<li><strong>Rust Code</strong>: Automatic memory safety through type system</li>
<li><strong>FFI Boundary</strong>: Manual validation with comprehensive testing</li>
<li><strong>C Code</strong>: Trust through NIST reference implementation quality</li>
</ul>
<h3 id="side-channel-resistance-1"><a class="header" href="#side-channel-resistance-1">Side-Channel Resistance</a></h3>
<ul>
<li>Constant-time implementations where feasible in C vendor code</li>
<li>Secure memory zeroization using Rust’s zeroize crate</li>
<li>Platform-specific secure random number generation</li>
</ul>
<h3 id="supply-chain-security"><a class="header" href="#supply-chain-security">Supply Chain Security</a></h3>
<ul>
<li>SHA-256 verification of all vendor C code</li>
<li>Reproducible build process</li>
<li>Version-controlled checksum validation</li>
<li>Build failure on integrity violations</li>
</ul>
<h2 id="attack-surface-analysis"><a class="header" href="#attack-surface-analysis">Attack Surface Analysis</a></h2>
<h3 id="primary-attack-vectors"><a class="header" href="#primary-attack-vectors">Primary Attack Vectors</a></h3>
<ol>
<li><strong>FFI Boundary Exploitation</strong>: Buffer overflows, type confusion</li>
<li><strong>Memory Safety Violations</strong>: Use-after-free, double-free in unsafe code</li>
<li><strong>Supply Chain Attacks</strong>: Compromised vendor code, build system tampering</li>
<li><strong>Side-Channel Analysis</strong>: Timing attacks, power analysis</li>
</ol>
<h3 id="mitigation-strategies"><a class="header" href="#mitigation-strategies">Mitigation Strategies</a></h3>
<ol>
<li><strong>Comprehensive Input Validation</strong>: All FFI inputs validated before C calls</li>
<li><strong>Bounded Buffer Operations</strong>: All C functions receive exact buffer sizes</li>
<li><strong>Integrity Verification</strong>: Cryptographic verification of vendor code</li>
<li><strong>Security Testing</strong>: Fuzzing, property-based testing, KAT validation</li>
</ol>
<h2 id="vendor-code-provenance"><a class="header" href="#vendor-code-provenance">Vendor Code Provenance</a></h2>
<p>All C implementations sourced from official NIST references:</p>
<ul>
<li><strong>ML-KEM</strong>: NIST FIPS 203 reference implementation</li>
<li><strong>ML-DSA</strong>: NIST FIPS 204 reference implementation</li>
<li><strong>Falcon</strong>: NIST PQC Round 3 submission</li>
<li><strong>SPHINCS+</strong>: NIST PQC Round 3 submission</li>
</ul>
<p>Each with SHA-256 integrity verification and controlled update process.</p>
<p>For complete technical details including FFI boundary analysis, memory safety model, and build process security, see the full <a href="architecture/../../ARCHITECTURE.html">Architecture Documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi-boundary-security"><a class="header" href="#ffi-boundary-security">FFI Boundary Security</a></h1>
<p>The Foreign Function Interface (FFI) boundary represents the most security-critical component of Cypheron Core, defining the transition between memory-safe Rust and potentially unsafe C implementations.</p>
<p>For complete technical analysis, see <a href="architecture/../../ARCHITECTURE.html#ffi-security-boundary-analysis">Architecture Documentation</a>.</p>
<h2 id="trust-boundary-model"><a class="header" href="#trust-boundary-model">Trust Boundary Model</a></h2>
<p>The FFI boundary creates a clear separation between trusted and untrusted zones:</p>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                    TRUSTED ZONE                             │
│  • Rust Application Code - Type &amp; Memory Safe              │
│  • Cypheron Safe Wrappers - Input Validation               │  
│  • Buffer Management - Lifetime Control                     │
├═════════════════════════════════════════════════════════════┤
│                    FFI SECURITY BOUNDARY                    │
├═════════════════════════════════════════════════════════════┤
│                    UNTRUSTED ZONE                           │
│  • NIST C Reference Code - Manual Memory Management        │
│  • Potential Undefined Behavior - Platform Specific       │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="data-flow-security"><a class="header" href="#data-flow-security">Data Flow Security</a></h2>
<h3 id="inbound-path-rust--c"><a class="header" href="#inbound-path-rust--c">Inbound Path (Rust → C)</a></h3>
<ol>
<li><strong>Input Validation</strong>: All parameters validated against algorithm specifications</li>
<li><strong>Buffer Preparation</strong>: Memory allocated with exact required sizes</li>
<li><strong>Pointer Safety</strong>: Raw pointers derived only from valid Rust references</li>
<li><strong>Length Verification</strong>: Buffer sizes cross-checked against C function expectations</li>
</ol>
<h3 id="outbound-path-c--rust"><a class="header" href="#outbound-path-c--rust">Outbound Path (C → Rust)</a></h3>
<ol>
<li><strong>Return Code Verification</strong>: All C function return values checked</li>
<li><strong>Output Validation</strong>: Generated data verified for proper initialization</li>
<li><strong>Size Consistency</strong>: Output lengths validated against expected algorithm outputs</li>
<li><strong>Memory Transfer</strong>: C-generated data safely transferred to Rust ownership</li>
</ol>
<h2 id="memory-ownership-model"><a class="header" href="#memory-ownership-model">Memory Ownership Model</a></h2>
<h3 id="pre-call-state"><a class="header" href="#pre-call-state">Pre-Call State</a></h3>
<ul>
<li>Rust allocates and owns all input and output buffers</li>
<li>Buffer sizes calculated from algorithm-specific constants</li>
<li>Pointers derived from valid Rust slice references</li>
</ul>
<h3 id="during-c-execution"><a class="header" href="#during-c-execution">During C Execution</a></h3>
<ul>
<li>Temporary shared access granted via raw pointers</li>
<li>Rust retains ownership but cannot access during execution</li>
<li>C code operates within provided buffer boundaries</li>
</ul>
<h3 id="post-call-state"><a class="header" href="#post-call-state">Post-Call State</a></h3>
<ul>
<li>Full ownership returns to Rust immediately</li>
<li>C-modified buffers validated for proper initialization</li>
<li>Sensitive data securely zeroized via Drop traits</li>
</ul>
<h2 id="safety-guarantees"><a class="header" href="#safety-guarantees">Safety Guarantees</a></h2>
<h3 id="buffer-boundary-protection"><a class="header" href="#buffer-boundary-protection">Buffer Boundary Protection</a></h3>
<ul>
<li>All buffer accesses validated before FFI calls</li>
<li>C functions receive exact sizes via separate length parameters</li>
<li>No C function can access memory beyond provided boundaries</li>
</ul>
<h3 id="type-safety-maintenance"><a class="header" href="#type-safety-maintenance">Type Safety Maintenance</a></h3>
<ul>
<li>Raw pointers used only for duration of C function calls</li>
<li>All data marshalling preserves Rust type invariants</li>
<li>No C pointers retained beyond function call scope</li>
</ul>
<h3 id="error-handling-isolation"><a class="header" href="#error-handling-isolation">Error Handling Isolation</a></h3>
<ul>
<li>C function errors isolated and converted to Rust error types</li>
<li>No C error state can compromise Rust memory safety</li>
<li>Failed operations trigger secure cleanup of sensitive data</li>
</ul>
<h3 id="concurrency-safety"><a class="header" href="#concurrency-safety">Concurrency Safety</a></h3>
<ul>
<li>FFI calls protected by appropriate synchronization primitives</li>
<li>No shared mutable state accessible across FFI boundary</li>
<li>Thread-local storage used for algorithm-specific contexts</li>
</ul>
<h2 id="example-safe-ffi-pattern"><a class="header" href="#example-safe-ffi-pattern">Example: Safe FFI Pattern</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn ml_kem_keypair() -&gt; Result&lt;(PublicKey, SecretKey), Error&gt; {
    // 1. Allocate buffers in Rust
    let mut pk = [0u8; ML_KEM_768_PUBLIC_KEY_BYTES];  
    let mut sk = [0u8; ML_KEM_768_SECRET_KEY_BYTES];
    
    // 2. Validate buffer sizes
    assert_eq!(pk.len(), ML_KEM_768_PUBLIC_KEY_BYTES);
    assert_eq!(sk.len(), ML_KEM_768_SECRET_KEY_BYTES);
    
    // 3. Call C function with temporary access
    let result = unsafe {
        pqcrystals_kyber768_ref_keypair(
            pk.as_mut_ptr(),    // Temporary pointer access
            sk.as_mut_ptr(),    // Rust maintains ownership
        )
    };
    
    // 4. Validate C function success
    if result != 0 {
        return Err(Error::KeygenFailed);
    }
    
    // 5. Verify output initialization (C code populated buffers)
    if pk.iter().all(|&amp;b| b == 0) || sk.iter().all(|&amp;b| b == 0) {
        return Err(Error::InvalidOutput);
    }
    
    // 6. Transfer ownership back to Rust types
    Ok((PublicKey::new(pk), SecretKey::new(sk)))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-testing"><a class="header" href="#security-testing">Security Testing</a></h2>
<p>The FFI boundary undergoes comprehensive testing:</p>
<ul>
<li><strong>Buffer Boundary Testing</strong>: Verify no out-of-bounds access</li>
<li><strong>Type Safety Validation</strong>: Ensure proper data marshalling</li>
<li><strong>Error Injection</strong>: Test error handling paths</li>
<li><strong>Fuzzing</strong>: Automated robustness testing with malformed inputs</li>
<li><strong>Memory Safety Analysis</strong>: AddressSanitizer and Valgrind testing</li>
</ul>
<p>For detailed implementation analysis including specific safety invariants for each unsafe block, see the <a href="architecture/../security/unsafe-guide.html">Unsafe Code Guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-safety-model"><a class="header" href="#memory-safety-model">Memory Safety Model</a></h1>
<p>Cypheron Core’s memory safety model defines how the library maintains safety guarantees while interfacing with potentially unsafe C vendor code.</p>
<p>For complete technical details, see <a href="architecture/../../ARCHITECTURE.html#memory-safety-model-and-trust-boundaries">Architecture Documentation</a>.</p>
<h2 id="memory-management-architecture"><a class="header" href="#memory-management-architecture">Memory Management Architecture</a></h2>
<h3 id="buffer-ownership-pattern"><a class="header" href="#buffer-ownership-pattern">Buffer Ownership Pattern</a></h3>
<p><strong>Rust-Owned Memory Model:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All cryptographic buffers allocated in Rust
let mut public_key = [0u8; ML_KEM_768_PUBLIC_KEY_BYTES];
let mut secret_key = [0u8; ML_KEM_768_SECRET_KEY_BYTES];

// Temporary access granted to C code
let result = unsafe {
    pqcrystals_kyber768_ref_keypair(
        public_key.as_mut_ptr(),    // Rust maintains ownership
        secret_key.as_mut_ptr(),    // C code gets temporary access
    )
};
// Ownership returns to Rust immediately
<span class="boring">}</span></code></pre></pre>
<h2 id="memory-lifecycle-management"><a class="header" href="#memory-lifecycle-management">Memory Lifecycle Management</a></h2>
<h3 id="1-allocation-phase"><a class="header" href="#1-allocation-phase">1. Allocation Phase</a></h3>
<ul>
<li>All buffers allocated by Rust with correct sizes</li>
<li>Stack allocation preferred for fixed-size cryptographic parameters</li>
<li>Heap allocation only when necessary, with explicit cleanup</li>
</ul>
<h3 id="2-access-phase"><a class="header" href="#2-access-phase">2. Access Phase</a></h3>
<ul>
<li>C code receives raw pointers with length information</li>
<li>Access duration limited to specific function call</li>
<li>No C code pointer retention beyond function scope</li>
</ul>
<h3 id="3-cleanup-phase"><a class="header" href="#3-cleanup-phase">3. Cleanup Phase</a></h3>
<ul>
<li>Sensitive data automatically zeroized by Drop implementations</li>
<li>No manual cleanup required in normal operation</li>
<li>Cleanup guaranteed even on panic conditions</li>
</ul>
<h2 id="safety-enforcement-mechanisms"><a class="header" href="#safety-enforcement-mechanisms">Safety Enforcement Mechanisms</a></h2>
<h3 id="pre-call-validation"><a class="header" href="#pre-call-validation">Pre-Call Validation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn validate_buffer_for_ffi&lt;T&gt;(buffer: &amp;[T], expected_len: usize) -&gt; bool {
    buffer.len() == expected_len &amp;&amp;           // Length verification
    !buffer.as_ptr().is_null() &amp;&amp;            // Non-null pointer
    buffer.as_ptr().is_aligned() &amp;&amp;          // Proper alignment
    is_valid_memory_range(buffer)             // Address space validation
}
<span class="boring">}</span></code></pre></pre>
<h3 id="buffer-bounds-protection"><a class="header" href="#buffer-bounds-protection">Buffer Bounds Protection</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FfiSafe {
    fn is_valid_for_ffi(&amp;self) -&gt; bool;
}

impl FfiSafe for &amp;[u8] {
    fn is_valid_for_ffi(&amp;self) -&gt; bool {
        !self.is_empty() &amp;&amp;                   // Non-empty buffer
        self.len() &lt;= isize::MAX as usize &amp;&amp;  // Size limits
        // Proper alignment
        self.as_ptr() as usize % std::mem::align_of::&lt;u8&gt;() == 0  
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="post-call-validation"><a class="header" href="#post-call-validation">Post-Call Validation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn verify_buffer_initialized(buffer: &amp;[u8], expected_len: usize) -&gt; bool {
    // Verify C code properly initialized buffer
    buffer.len() == expected_len &amp;&amp;
    // Additional cryptographic output validation
    verify_crypto_output_validity(buffer)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="secure-memory-management"><a class="header" href="#secure-memory-management">Secure Memory Management</a></h2>
<h3 id="secret-key-protection"><a class="header" href="#secret-key-protection">Secret Key Protection</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use secrecy::{SecretBox, ExposeSecret, Zeroize};

pub struct SecretKey(SecretBox&lt;[u8; ML_DSA_SECRET_KEY_BYTES]&gt;);

impl SecretKey {
    pub fn expose_for_ffi&lt;F, R&gt;(&amp;self, f: F) -&gt; R 
    where 
        F: FnOnce(&amp;[u8]) -&gt; R 
    {
        // Controlled access to secret material
        self.0.expose_secret(f)
    }
}

impl Drop for SecretKey {
    fn drop(&amp;mut self) {
        // Automatic secure cleanup
        self.0.expose_secret_mut(|s| s.zeroize());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-protection"><a class="header" href="#memory-protection">Memory Protection</a></h3>
<ul>
<li><strong>Stack Protection</strong>: Fixed-size buffers on stack when possible</li>
<li><strong>Heap Isolation</strong>: Dynamic allocation with secure cleanup</li>
<li><strong>Zeroization</strong>: All sensitive data cleared on drop</li>
<li><strong>ASLR Support</strong>: Position-independent code generation</li>
</ul>
<h2 id="trust-zone-classification"><a class="header" href="#trust-zone-classification">Trust Zone Classification</a></h2>
<h3 id="fully-trusted-zone-1"><a class="header" href="#fully-trusted-zone-1">Fully Trusted Zone</a></h3>
<ul>
<li><strong>Rust Application Code</strong>: Memory safety guaranteed by compiler</li>
<li><strong>Safe API Layer</strong>: Type safety enforced automatically</li>
<li><strong>Standard Library</strong>: Rust std library safety guarantees</li>
</ul>
<h3 id="conditionally-trusted-zone-1"><a class="header" href="#conditionally-trusted-zone-1">Conditionally Trusted Zone</a></h3>
<ul>
<li><strong>Unsafe Wrappers</strong>: Manual safety verification through code review</li>
<li><strong>FFI Management</strong>: Comprehensive testing and validation</li>
<li><strong>Platform Code</strong>: OS-specific implementations with error handling</li>
</ul>
<h3 id="untrusted-zone-1"><a class="header" href="#untrusted-zone-1">Untrusted Zone</a></h3>
<ul>
<li><strong>C Reference Code</strong>: Manual memory management, potential UB</li>
<li><strong>Vendor Libraries</strong>: Trust through testing and verification</li>
<li><strong>System Interfaces</strong>: OS APIs with proper error handling</li>
</ul>
<h2 id="memory-safety-testing"><a class="header" href="#memory-safety-testing">Memory Safety Testing</a></h2>
<h3 id="validation-methods"><a class="header" href="#validation-methods">Validation Methods</a></h3>
<ol>
<li><strong>Static Analysis</strong>: Rust compiler checks and Clippy lints</li>
<li><strong>Dynamic Testing</strong>: AddressSanitizer and MemorySanitizer</li>
<li><strong>Fuzzing</strong>: Automated testing with malformed inputs</li>
<li><strong>Property Testing</strong>: Cryptographic property verification</li>
<li><strong>Manual Review</strong>: Code review of all unsafe blocks</li>
</ol>
<h3 id="continuous-validation"><a class="header" href="#continuous-validation">Continuous Validation</a></h3>
<ul>
<li><strong>CI/CD Integration</strong>: Memory safety testing on all commits</li>
<li><strong>Platform Testing</strong>: Validation across Linux, macOS, Windows</li>
<li><strong>Regression Prevention</strong>: Automated detection of safety violations</li>
<li><strong>Documentation</strong>: All unsafe code documented with safety invariants</li>
</ul>
<h2 id="safety-guarantees-1"><a class="header" href="#safety-guarantees-1">Safety Guarantees</a></h2>
<h3 id="what-we-guarantee"><a class="header" href="#what-we-guarantee">What We Guarantee</a></h3>
<ul>
<li><strong>No Buffer Overflows</strong>: All C function calls bounds-checked</li>
<li><strong>No Use-After-Free</strong>: Rust ownership model prevents dangling pointers</li>
<li><strong>No Double-Free</strong>: Single ownership prevents multiple deallocation</li>
<li><strong>Secure Cleanup</strong>: All sensitive data zeroized on drop</li>
</ul>
<h3 id="what-we-dont-guarantee"><a class="header" href="#what-we-dont-guarantee">What We Don’t Guarantee</a></h3>
<ul>
<li><strong>C Code Internal Safety</strong>: Reliant on NIST reference quality</li>
<li><strong>Side-Channel Resistance</strong>: Depends on C implementation properties</li>
<li><strong>Perfect Forward Secrecy</strong>: Application-level concern</li>
<li><strong>Quantum Resistance</strong>: Depends on algorithm security assumptions</li>
</ul>
<p>For complete technical analysis including specific memory management patterns and safety invariants, see the full <a href="architecture/../../ARCHITECTURE.html">Architecture Documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-model-1"><a class="header" href="#security-model-1">Security Model</a></h1>
<blockquote>
<p><strong>DEVELOPMENT STATUS WARNING</strong></p>
<p>This security model describes the INTENDED security properties of Cypheron Core v0.1.0.</p>
<p><strong>CRITICAL</strong>: This is a Rust wrapper around official NIST reference implementations - not custom cryptography.
The core algorithms are NIST-certified, but the Rust integration layer is experimental and has NOT been:</p>
<ul>
<li>Independently audited for FFI safety</li>
<li>Formally verified for memory management</li>
<li>Validated in production environments</li>
</ul>
<p>Integration layer uses C vendor code with Rust FFI bindings requiring security evaluation.</p>
</blockquote>
<p>Cypheron Core’s security model describes intended cryptographic foundations and defensive programming practices.</p>
<h2 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h2>
<h3 id="adversarial-capabilities"><a class="header" href="#adversarial-capabilities">Adversarial Capabilities</a></h3>
<p>We protect against adversaries with the following capabilities:</p>
<ol>
<li><strong>Classical Computers</strong>: Unlimited classical computational power</li>
<li><strong>Quantum Computers</strong>: Large-scale fault-tolerant quantum computers</li>
<li><strong>Side-Channel Attacks</strong>: Timing, power, and electromagnetic analysis</li>
<li><strong>Memory Attacks</strong>: Cold boot attacks, memory dumps, swap file analysis</li>
</ol>
<h3 id="security-goals"><a class="header" href="#security-goals">Security Goals</a></h3>
<ul>
<li><strong>Confidentiality</strong>: Encrypted data remains secret</li>
<li><strong>Authenticity</strong>: Signatures prove message origin</li>
<li><strong>Integrity</strong>: Tampering is detectable</li>
<li><strong>Forward Secrecy</strong>: Past communications remain secure if keys are compromised</li>
</ul>
<h2 id="cryptographic-security"><a class="header" href="#cryptographic-security">Cryptographic Security</a></h2>
<h3 id="post-quantum-resistance"><a class="header" href="#post-quantum-resistance">Post-Quantum Resistance</a></h3>
<p>All algorithms are designed to resist quantum computer attacks:</p>
<ul>
<li><strong>ML-KEM</strong>: Based on Module Learning With Errors (M-LWE)</li>
<li><strong>ML-DSA</strong>: Based on Module Short Integer Solution (M-SIS)</li>
<li><strong>Falcon</strong>: Based on NTRU lattices and Gaussian sampling</li>
<li><strong>SPHINCS+</strong>: Based on hash functions and one-time signatures</li>
</ul>
<h3 id="security-levels-3"><a class="header" href="#security-levels-3">Security Levels</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Level</th><th>Classical Security</th><th>Quantum Security</th><th>Real-World Equivalent</th></tr></thead><tbody>
<tr><td>1</td><td>128-bit</td><td>64-bit</td><td>AES-128</td></tr>
<tr><td>2</td><td>128-bit</td><td>64-bit</td><td>SHA-256</td></tr>
<tr><td>3</td><td>192-bit</td><td>96-bit</td><td>AES-192</td></tr>
<tr><td>4</td><td>192-bit</td><td>96-bit</td><td>SHA-256</td></tr>
<tr><td>5</td><td>256-bit</td><td>128-bit</td><td>AES-256</td></tr>
</tbody></table>
</div>
<h2 id="implementation-security"><a class="header" href="#implementation-security">Implementation Security</a></h2>
<h3 id="constant-time-operations"><a class="header" href="#constant-time-operations">Constant-Time Operations</a></h3>
<p>All cryptographic operations execute in constant time:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example: Constant-time secret key usage
let (pk, sk) = MlKem768::keypair()?;
let (ct, ss) = MlKem768::encapsulate(&amp;pk)?;

// Decapsulation time is independent of:
// - Secret key content
// - Ciphertext validity  
// - Previous operations
let result = MlKem768::decapsulate(&amp;ct, &amp;sk)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-protection-1"><a class="header" href="#memory-protection-1">Memory Protection</a></h3>
<p>Sensitive data is automatically protected:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use secrecy::ExposeSecret;

{
    let (pk, sk) = MlKem768::keypair()?;
    
    // Secret key is in protected memory
    let secret_data = sk.0.expose_secret();
    
    // Use secret_data...
    
} // Secret key memory is zeroized automatically
<span class="boring">}</span></code></pre></pre>
<h3 id="randomness-requirements"><a class="header" href="#randomness-requirements">Randomness Requirements</a></h3>
<p>Cryptographic operations require high-quality randomness:</p>
<ul>
<li><strong>Entropy Sources</strong>: Hardware RNG, OS entropy pools</li>
<li><strong>Seeding</strong>: Proper CSPRNG initialization</li>
<li><strong>Reseeding</strong>: Regular entropy pool updates</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Entropy failure is handled gracefully
match MlKem768::keypair() {
    Ok((pk, sk)) =&gt; { /* success */ },
    Err(MlKemError::KeyGenerationEntropyFailure) =&gt; {
        // Handle insufficient entropy
        std::thread::sleep(std::time::Duration::from_millis(100));
        // Retry...
    },
    Err(e) =&gt; return Err(e),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="side-channel-protection-1"><a class="header" href="#side-channel-protection-1">Side-Channel Protection</a></h2>
<h3 id="timing-attacks"><a class="header" href="#timing-attacks">Timing Attacks</a></h3>
<p>All operations use constant-time algorithms:</p>
<ul>
<li><strong>No secret-dependent branches</strong>: Control flow is independent of secrets</li>
<li><strong>No secret-dependent memory access</strong>: Memory patterns are predictable</li>
<li><strong>No secret-dependent loop bounds</strong>: Iteration counts are fixed</li>
</ul>
<h3 id="power-analysis"><a class="header" href="#power-analysis">Power Analysis</a></h3>
<p>Operations are designed to minimize power analysis vulnerabilities:</p>
<ul>
<li><strong>Uniform operations</strong>: Similar power consumption patterns</li>
<li><strong>Masked arithmetic</strong>: Secret values are never used directly</li>
<li><strong>Randomized execution</strong>: Some operations include deliberate randomness</li>
</ul>
<h3 id="fault-injection"><a class="header" href="#fault-injection">Fault Injection</a></h3>
<p>Critical operations include integrity checks:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example: Built-in integrity verification
let (pk, sk) = MlKem768::keypair()?;
let (ct, ss1) = MlKem768::encapsulate(&amp;pk)?;

// Decapsulation includes implicit ciphertext validation
match MlKem768::decapsulate(&amp;ct, &amp;sk) {
    Ok(ss2) =&gt; {
        // ss1 and ss2 are identical if no faults occurred
        assert_eq!(ss1.expose_secret(), ss2.expose_secret());
    },
    Err(MlKemError::DecapsulationInvalidCiphertext) =&gt; {
        // Ciphertext was corrupted or maliciously modified
    },
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-management-2"><a class="header" href="#key-management-2">Key Management</a></h2>
<h3 id="key-lifecycle"><a class="header" href="#key-lifecycle">Key Lifecycle</a></h3>
<ol>
<li><strong>Generation</strong>: High-entropy key creation</li>
<li><strong>Storage</strong>: Encrypted at rest when possible</li>
<li><strong>Usage</strong>: Minimal exposure time</li>
<li><strong>Destruction</strong>: Cryptographic erasure</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Proper key lifecycle management
fn secure_key_usage() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // 1. Generation
    let (pk, sk) = MlKem768::keypair()?;
    
    // 2. Usage (minimize exposure time)
    let (ct, ss) = MlKem768::encapsulate(&amp;pk)?;
    
    // 3. Destruction is automatic when variables go out of scope
    Ok(())
} // Keys are zeroized here
<span class="boring">}</span></code></pre></pre>
<h3 id="key-rotation"><a class="header" href="#key-rotation">Key Rotation</a></h3>
<p>Regular key rotation is recommended:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::{Duration, Instant};

struct KeyManager {
    current_keys: (MlKemPublicKey, MlKemSecretKey),
    created_at: Instant,
    rotation_interval: Duration,
}

impl KeyManager {
    fn should_rotate(&amp;self) -&gt; bool {
        self.created_at.elapsed() &gt; self.rotation_interval
    }
    
    fn rotate(&amp;mut self) -&gt; Result&lt;(), MlKemError&gt; {
        if self.should_rotate() {
            self.current_keys = MlKem768::keypair()?;
            self.created_at = Instant::now();
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="compliance-and-standards"><a class="header" href="#compliance-and-standards">Compliance and Standards</a></h2>
<h3 id="nist-standardization"><a class="header" href="#nist-standardization">NIST Standardization</a></h3>
<p>All algorithms implement NIST-standardized specifications:</p>
<ul>
<li><strong>FIPS 203</strong>: ML-KEM standard</li>
<li><strong>FIPS 204</strong>: ML-DSA standard</li>
<li><strong>FIPS 205</strong>: SPHINCS+ standard</li>
</ul>
<h3 id="security-validations"><a class="header" href="#security-validations">Security Validations</a></h3>
<ul>
<li><strong>Known Answer Tests (KAT)</strong>: Validation against NIST test vectors</li>
<li><strong>Monte Carlo Testing</strong>: Statistical randomness validation</li>
<li><strong>Side-Channel Testing</strong>: Timing and power analysis resistance</li>
</ul>
<h2 id="limitations-and-assumptions"><a class="header" href="#limitations-and-assumptions">Limitations and Assumptions</a></h2>
<h3 id="trust-assumptions"><a class="header" href="#trust-assumptions">Trust Assumptions</a></h3>
<ul>
<li><strong>Implementation Correctness</strong>: No bugs in cryptographic implementations</li>
<li><strong>Hardware Security</strong>: CPU and memory provide basic security guarantees</li>
<li><strong>Random Number Generation</strong>: OS provides cryptographically secure randomness</li>
</ul>
<h3 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h3>
<ul>
<li><strong>No Perfect Forward Secrecy</strong>: KEM schemes don’t provide PFS by default</li>
<li><strong>Post-Quantum Assumptions</strong>: Security relies on unproven mathematical assumptions</li>
<li><strong>Implementation Attacks</strong>: Hardware vulnerabilities could compromise security</li>
</ul>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="application-security"><a class="header" href="#application-security">Application Security</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good: Validate all inputs
if ciphertext.len() != EXPECTED_CIPHERTEXT_SIZE {
    return Err("Invalid ciphertext size");
}

// ✅ Good: Handle errors appropriately  
match MlKem768::decapsulate(&amp;ct, &amp;sk) {
    Ok(ss) =&gt; use_shared_secret(ss),
    Err(e) =&gt; log_security_event(e),
}

// ❌ Bad: Ignoring security-critical errors
let ss = MlKem768::decapsulate(&amp;ct, &amp;sk).unwrap(); // Don't do this!
<span class="boring">}</span></code></pre></pre>
<h3 id="operational-security"><a class="header" href="#operational-security">Operational Security</a></h3>
<ol>
<li><strong>Monitor Entropy</strong>: Check system entropy levels</li>
<li><strong>Log Security Events</strong>: Record cryptographic failures</li>
<li><strong>Update Regularly</strong>: Keep libraries up to date</li>
<li><strong>Test Thoroughly</strong>: Validate all error paths</li>
</ol>
<h2 id="see-also-6"><a class="header" href="#see-also-6">See Also</a></h2>
<ul>
<li><a href="security/side-channels.html">Side-Channel Protection</a> - Detailed protection mechanisms</li>
<li><a href="security/memory.html">Memory Safety</a> - Memory security guarantees</li>
<li><a href="security/compliance.html">Compliance</a> - Standards compliance</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vulnerability-reporting"><a class="header" href="#vulnerability-reporting">Vulnerability Reporting</a></h1>
<p>For comprehensive security vulnerability reporting procedures, please see our <a href="security/../../SECURITY.html">Security Policy</a>.</p>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<p><strong>For security vulnerabilities, please report privately to:</strong></p>
<ul>
<li>Email: michael@cypheronlabs.com</li>
<li>Subject Line: [SECURITY] Brief description of issue</li>
</ul>
<p><strong>Please do NOT:</strong></p>
<ul>
<li>Open public GitHub issues for security vulnerabilities</li>
<li>Discuss security issues in public forums or chat rooms</li>
<li>Share vulnerabilities on social media before resolution</li>
</ul>
<h2 id="response-timeline"><a class="header" href="#response-timeline">Response Timeline</a></h2>
<ul>
<li><strong>Initial Response:</strong> Within 48 hours of report</li>
<li><strong>Assessment:</strong> Within 7 days for severity classification</li>
<li><strong>Resolution:</strong> Timeline depends on complexity and severity</li>
<li><strong>Disclosure:</strong> Coordinated disclosure after fix is available</li>
</ul>
<h2 id="what-to-include"><a class="header" href="#what-to-include">What to Include</a></h2>
<ol>
<li><strong>Vulnerability Description:</strong> Clear explanation of the issue</li>
<li><strong>Impact Assessment:</strong> Potential security implications</li>
<li><strong>Reproduction Steps:</strong> Detailed steps to reproduce the issue</li>
<li><strong>Proof of Concept:</strong> Code or commands demonstrating the vulnerability</li>
<li><strong>Environment Details:</strong> Operating system, Rust version, library version</li>
<li><strong>Suggested Fix:</strong> If you have recommendations for resolution</li>
</ol>
<p>For complete details including scope, security model, and recognition policy, see the full <a href="security/../../SECURITY.html">Security Policy</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-code-guide"><a class="header" href="#unsafe-code-guide">Unsafe Code Guide</a></h1>
<p>Cypheron Core contains unsafe Rust code required for FFI integration with NIST C reference implementations. This section provides an overview of our unsafe code usage and safety guarantees.</p>
<p>For complete documentation of all unsafe code blocks, see the comprehensive <a href="security/../../UNSAFE_GUIDE.html">Unsafe Code Guide</a>.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>The library contains <strong>91 unsafe blocks</strong> across <strong>19 files</strong>, each with detailed safety justifications. All unsafe code is:</p>
<ul>
<li>Documented with safety invariants</li>
<li>Required for FFI with C vendor code</li>
<li>Minimized to essential operations</li>
<li>Reviewed for memory safety</li>
</ul>
<h2 id="categories-of-unsafe-code"><a class="header" href="#categories-of-unsafe-code">Categories of Unsafe Code</a></h2>
<h3 id="1-ffi-function-calls"><a class="header" href="#1-ffi-function-calls">1. FFI Function Calls</a></h3>
<p>Direct calls to C cryptographic functions from NIST reference implementations.</p>
<p><strong>Safety Guarantee:</strong> Buffer bounds validated before calls, return codes checked.</p>
<h3 id="2-pointer-dereferencing"><a class="header" href="#2-pointer-dereferencing">2. Pointer Dereferencing</a></h3>
<p>Converting Rust slices to raw pointers for C function parameters.</p>
<p><strong>Safety Guarantee:</strong> Pointers derived from valid Rust references, lifetimes controlled.</p>
<h3 id="3-memory-operations"><a class="header" href="#3-memory-operations">3. Memory Operations</a></h3>
<p>Buffer initialization and secure cleanup operations.</p>
<p><strong>Safety Guarantee:</strong> All operations within allocated bounds, proper initialization verified.</p>
<h3 id="4-platform-specific-code"><a class="header" href="#4-platform-specific-code">4. Platform-Specific Code</a></h3>
<p>OS-specific secure random number generation and memory protection.</p>
<p><strong>Safety Guarantee:</strong> Platform APIs used according to documentation, error handling comprehensive.</p>
<h2 id="security-audit-considerations"><a class="header" href="#security-audit-considerations">Security Audit Considerations</a></h2>
<p>Each unsafe block is documented with:</p>
<ul>
<li><strong>Safety Invariant:</strong> What conditions must hold for safety</li>
<li><strong>Justification:</strong> Why the unsafe operation is necessary</li>
<li><strong>Verification:</strong> How safety is ensured in practice</li>
<li><strong>Error Handling:</strong> What happens when invariants are violated</li>
</ul>
<h2 id="complete-documentation"><a class="header" href="#complete-documentation">Complete Documentation</a></h2>
<p>For detailed analysis of every unsafe block including line-by-line safety justifications, see:</p>
<ul>
<li><a href="security/../../UNSAFE_GUIDE.html"><strong>Complete Unsafe Code Guide (UNSAFE_GUIDE.md)</strong></a></li>
</ul>
<p>This comprehensive guide provides security auditors with complete visibility into all potentially unsafe operations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audit-readiness"><a class="header" href="#audit-readiness">Audit Readiness</a></h1>
<p>Cypheron Core (v0.1.1) has been prepared for professional security audits with comprehensive documentation and transparency measures.</p>
<h2 id="current-status"><a class="header" href="#current-status">Current Status</a></h2>
<p><strong>Status:</strong> [X] <strong>AUDIT READY</strong> - Complete documentation and security analysis finished<br />
<strong>Phase:</strong> Seeking community audit and professional security evaluation<br />
<strong>Timeline:</strong> Q4 2025 community audit, 2026 professional audit</p>
<h2 id="audit-documentation-package"><a class="header" href="#audit-documentation-package">Audit Documentation Package</a></h2>
<h3 id="1-security-architecture"><a class="header" href="#1-security-architecture">1. Security Architecture</a></h3>
<ul>
<li><a href="security/../architecture/security.html"><strong>Security Architecture</strong></a> - Complete security model</li>
<li><a href="security/../architecture/ffi.html"><strong>FFI Boundary Analysis</strong></a> - Trust boundaries and memory safety</li>
<li><a href="security/../architecture/memory.html"><strong>Memory Safety Model</strong></a> - Safety guarantees and validation</li>
</ul>
<h3 id="2-code-transparency"><a class="header" href="#2-code-transparency">2. Code Transparency</a></h3>
<ul>
<li><a href="security/../../UNSAFE_GUIDE.html"><strong>Unsafe Code Guide</strong></a> - All 91 unsafe blocks documented</li>
<li><a href="security/../development/build.html"><strong>Build System Security</strong></a> - Secure compilation process</li>
<li><a href="security/../architecture/security.html#vendor-code-provenance"><strong>Vendor Code Integrity</strong></a> - Supply chain security</li>
</ul>
<h3 id="3-security-policies"><a class="header" href="#3-security-policies">3. Security Policies</a></h3>
<ul>
<li><a href="security/../../SECURITY.html"><strong>Security Policy</strong></a> - Vulnerability reporting and response</li>
<li><a href="security/../../ROADMAP.html"><strong>Development Roadmap</strong></a> - Current priorities and timeline</li>
</ul>
<h2 id="audit-scope"><a class="header" href="#audit-scope">Audit Scope</a></h2>
<h3 id="in-scope"><a class="header" href="#in-scope">In Scope</a></h3>
<ul>
<li>FFI boundary security between Rust and C code</li>
<li>Memory safety of wrapper implementations</li>
<li>Build system security and vendor code integrity</li>
<li>API design and usage patterns</li>
<li>Error handling and secure cleanup</li>
<li>Platform-specific security implementations</li>
</ul>
<h3 id="out-of-scope"><a class="header" href="#out-of-scope">Out of Scope</a></h3>
<ul>
<li>NIST C reference implementation algorithms (externally audited)</li>
<li>Standard Rust compiler safety guarantees</li>
<li>Operating system security features</li>
<li>Network protocol implementations (none present)</li>
</ul>
<h2 id="auditor-resources"><a class="header" href="#auditor-resources">Auditor Resources</a></h2>
<h3 id="documentation-hierarchy"><a class="header" href="#documentation-hierarchy">Documentation Hierarchy</a></h3>
<pre><code>PROJECT ROOT/
├── SECURITY.md              # Primary security policy
├── ARCHITECTURE.md          # Complete security architecture  
├── UNSAFE_GUIDE.md          # All unsafe code documentation
├── ROADMAP.md              # Development status and priorities
└── docs/                   # Comprehensive documentation
    ├── security/           # Security-focused documentation
    ├── architecture/       # Technical architecture details
    └── development/        # Build and development processes
</code></pre>
<h3 id="key-audit-entry-points"><a class="header" href="#key-audit-entry-points">Key Audit Entry Points</a></h3>
<ol>
<li><a href="security/model.html"><strong>Security Model</strong></a> - Start here for overall security approach</li>
<li><a href="security/../architecture/ffi.html"><strong>FFI Boundary</strong></a> - Primary attack surface analysis</li>
<li><a href="security/unsafe-guide.html"><strong>Unsafe Code Guide</strong></a> - All potentially vulnerable code sections</li>
</ol>
<h2 id="community-audit-process"><a class="header" href="#community-audit-process">Community Audit Process</a></h2>
<h3 id="current-phase-community-validation"><a class="header" href="#current-phase-community-validation">Current Phase: Community Validation</a></h3>
<ul>
<li>Open source security community review</li>
<li>Academic cryptography community feedback</li>
<li>Independent security researcher analysis</li>
<li>Public vulnerability disclosure process</li>
</ul>
<h3 id="how-to-participate"><a class="header" href="#how-to-participate">How to Participate</a></h3>
<ul>
<li>Review <a href="security/reporting.html">Security Policy</a> for vulnerability reporting</li>
<li>Examine <a href="security/../../UNSAFE_GUIDE.html">Unsafe Code Guide</a> for code analysis</li>
<li>Test security properties using provided test suite</li>
<li>Report findings through responsible disclosure process</li>
</ul>
<h2 id="professional-audit-preparation"><a class="header" href="#professional-audit-preparation">Professional Audit Preparation</a></h2>
<p>Following successful community validation:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Engage qualified cryptographic auditing firm</li>
<li><input disabled="" type="checkbox"/>
Execute formal security audit of all components</li>
<li><input disabled="" type="checkbox"/>
Address any findings from security audit</li>
<li><input disabled="" type="checkbox"/>
Obtain public security audit report</li>
<li><input disabled="" type="checkbox"/>
Prepare for production release</li>
</ul>
<h2 id="standards-compliance"><a class="header" href="#standards-compliance">Standards Compliance</a></h2>
<p>Prepared for evaluation against:</p>
<ul>
<li>NIST post-quantum cryptography standards (FIPS 203, 204, 205)</li>
<li>Memory safety best practices for Rust FFI</li>
<li>Supply chain security standards</li>
<li>Open source security audit methodologies</li>
</ul>
<p>For current development status and priorities, see the <a href="security/../../ROADMAP.html">Development Roadmap</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-guidelines"><a class="header" href="#contributing-guidelines">Contributing Guidelines</a></h1>
<p>We welcome contributions to Cypheron Core! This project implements post-quantum cryptography with a focus on security and reliability.</p>
<h2 id="development-status"><a class="header" href="#development-status">Development Status</a></h2>
<p><strong>Current Phase:</strong> Seeking community audit and validation (Q4 2025)
<strong>Status:</strong> v0.1.1 - Foundation complete, documentation finished</p>
<h2 id="areas-for-contribution"><a class="header" href="#areas-for-contribution">Areas for Contribution</a></h2>
<h3 id="high-priority"><a class="header" href="#high-priority">High Priority</a></h3>
<ol>
<li><strong>Security Analysis</strong> - Review FFI boundary implementations</li>
<li><strong>Code Review</strong> - Examine unsafe code blocks and safety justifications</li>
<li><strong>Testing</strong> - Add test cases, fuzzing, property-based testing</li>
<li><strong>Documentation</strong> - Improve API docs and usage examples</li>
</ol>
<h3 id="standard-contributions"><a class="header" href="#standard-contributions">Standard Contributions</a></h3>
<ul>
<li>Bug fixes and error handling improvements</li>
<li>Performance optimizations</li>
<li>Platform compatibility enhancements</li>
<li>Build system improvements</li>
</ul>
<h2 id="security-focused-development"><a class="header" href="#security-focused-development">Security-Focused Development</a></h2>
<h3 id="required-reading"><a class="header" href="#required-reading">Required Reading</a></h3>
<p>Before contributing, please review:</p>
<ul>
<li><a href="development/../../SECURITY.html">Security Policy</a> - Vulnerability reporting process</li>
<li><a href="development/../../UNSAFE_GUIDE.html">Unsafe Code Guide</a> - All unsafe code documentation</li>
<li><a href="development/../../ARCHITECTURE.html">Architecture</a> - Complete security architecture</li>
</ul>
<h3 id="security-requirements"><a class="header" href="#security-requirements">Security Requirements</a></h3>
<ul>
<li>All unsafe code must include detailed safety justifications</li>
<li>FFI boundary changes require comprehensive testing</li>
<li>Memory safety must be preserved across all changes</li>
<li>Security properties must be validated</li>
</ul>
<h2 id="development-process"><a class="header" href="#development-process">Development Process</a></h2>
<h3 id="1-setup"><a class="header" href="#1-setup">1. Setup</a></h3>
<pre><code class="language-bash">git clone https://github.com/CypheronLabs/Cypheron-core.git
cd Cypheron-core
cargo build
cargo test
</code></pre>
<h3 id="2-code-standards"><a class="header" href="#2-code-standards">2. Code Standards</a></h3>
<ul>
<li>Follow Rust standard formatting with <code>cargo fmt</code></li>
<li>Pass all lints with <code>cargo clippy</code></li>
<li>Maintain comprehensive test coverage</li>
<li>Document all public APIs</li>
</ul>
<h3 id="3-testing-requirements"><a class="header" href="#3-testing-requirements">3. Testing Requirements</a></h3>
<ul>
<li>Unit tests for all new functionality</li>
<li>Integration tests for algorithm implementations</li>
<li>Known Answer Tests (KAT) for NIST compliance</li>
<li>Property-based testing for cryptographic properties</li>
</ul>
<h3 id="4-submission-process"><a class="header" href="#4-submission-process">4. Submission Process</a></h3>
<ul>
<li>Fork the repository</li>
<li>Create feature branch from main</li>
<li>Implement changes with tests</li>
<li>Run full test suite</li>
<li>Submit pull request with detailed description</li>
</ul>
<h2 id="pull-request-guidelines"><a class="header" href="#pull-request-guidelines">Pull Request Guidelines</a></h2>
<h3 id="required-information"><a class="header" href="#required-information">Required Information</a></h3>
<ul>
<li><strong>Purpose</strong>: Clear description of changes and motivation</li>
<li><strong>Testing</strong>: Evidence of comprehensive testing</li>
<li><strong>Security Impact</strong>: Analysis of security implications</li>
<li><strong>Documentation</strong>: Updates to relevant documentation</li>
</ul>
<h3 id="review-process"><a class="header" href="#review-process">Review Process</a></h3>
<ul>
<li><strong>Code Review</strong>: Technical implementation review</li>
<li><strong>Security Review</strong>: Security implications analysis</li>
<li><strong>Testing Validation</strong>: Comprehensive test execution</li>
<li><strong>Documentation Check</strong>: Accuracy and completeness</li>
</ul>
<h2 id="unsafe-code-contributions"><a class="header" href="#unsafe-code-contributions">Unsafe Code Contributions</a></h2>
<p>Changes to unsafe code require additional scrutiny:</p>
<h3 id="documentation-requirements"><a class="header" href="#documentation-requirements">Documentation Requirements</a></h3>
<ul>
<li><strong>Safety Invariant</strong>: What conditions ensure safety</li>
<li><strong>Justification</strong>: Why unsafe code is necessary</li>
<li><strong>Verification</strong>: How safety is validated</li>
<li><strong>Error Handling</strong>: Behavior when invariants are violated</li>
</ul>
<h3 id="review-process-1"><a class="header" href="#review-process-1">Review Process</a></h3>
<ul>
<li>Manual code review by multiple contributors</li>
<li>Comprehensive testing including edge cases</li>
<li>Memory safety validation with sanitizers</li>
<li>Documentation accuracy verification</li>
</ul>
<h2 id="community-standards"><a class="header" href="#community-standards">Community Standards</a></h2>
<h3 id="communication"><a class="header" href="#communication">Communication</a></h3>
<ul>
<li>Respectful and professional interaction</li>
<li>Constructive feedback and suggestions</li>
<li>Focus on technical merit and security</li>
</ul>
<h3 id="quality-standards"><a class="header" href="#quality-standards">Quality Standards</a></h3>
<ul>
<li>High-quality implementations</li>
<li>Comprehensive testing</li>
<li>Clear documentation</li>
<li>Security-first mindset</li>
</ul>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<h3 id="questions-and-support"><a class="header" href="#questions-and-support">Questions and Support</a></h3>
<ul>
<li><strong>GitHub Discussions</strong>: Technical questions and design discussions</li>
<li><strong>GitHub Issues</strong>: Bug reports and feature requests (non-security)</li>
<li><strong>Security Issues</strong>: Private disclosure via <a href="development/../../SECURITY.html">Security Policy</a></li>
</ul>
<h3 id="resources"><a class="header" href="#resources">Resources</a></h3>
<ul>
<li><a href="development/../architecture/overview.html">Architecture Overview</a></li>
<li><a href="development/../security/model.html">Security Model</a></li>
<li><a href="development/../architecture/ffi.html">FFI Boundary Analysis</a></li>
<li><a href="development/../getting-started/roadmap.html">Development Roadmap</a></li>
</ul>
<h2 id="recognition"><a class="header" href="#recognition">Recognition</a></h2>
<p>Contributors will be acknowledged in:</p>
<ul>
<li>Release notes for significant contributions</li>
<li>Project documentation for major features</li>
<li>Security credits for vulnerability reports</li>
</ul>
<p>Thank you for helping make post-quantum cryptography accessible and secure!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-system-security"><a class="header" href="#build-system-security">Build System Security</a></h1>
<p>Cypheron Core’s build system implements comprehensive security measures to safely compile potentially untrusted C vendor code while maintaining security guarantees.</p>
<p>For complete technical details, see <a href="development/../../ARCHITECTURE.html#build-process-security-architecture">Architecture Documentation</a>.</p>
<h2 id="build-security-pipeline"><a class="header" href="#build-security-pipeline">Build Security Pipeline</a></h2>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                    BUILD SECURITY PIPELINE                  │
├─────────────────────────────────────────────────────────────┤
│ 1. Pre-Build Security Checks                                │
│    ├─ Vendor code integrity verification                    │
│    ├─ Build dependency validation                           │
│    └─ Toolchain security verification                       │
├─────────────────────────────────────────────────────────────┤
│ 2. Secure Compilation Phase                                 │  
│    ├─ Security-hardened compiler flags                      │
│    ├─ Platform-specific optimizations                       │
│    └─ Stack protection enablement                           │
├─────────────────────────────────────────────────────────────┤
│ 3. FFI Binding Generation                                   │
│    ├─ API surface minimization                              │
│    ├─ Function allowlisting                                 │
│    └─ Type safety enforcement                               │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="vendor-code-integrity"><a class="header" href="#vendor-code-integrity">Vendor Code Integrity</a></h2>
<h3 id="verification-process"><a class="header" href="#verification-process">Verification Process</a></h3>
<pre><code class="language-bash"># Automated integrity verification
find vendor/ -name "*.c" -o -name "*.h" | xargs sha256sum &gt; SHA256SUMS
sha256sum -c SHA256SUMS
</code></pre>
<h3 id="security-properties-1"><a class="header" href="#security-properties-1">Security Properties</a></h3>
<ul>
<li><strong>Tamper Detection</strong>: Any modification to vendor code detected immediately</li>
<li><strong>Reproducible Builds</strong>: Consistent verification across environments</li>
<li><strong>Build Failure on Mismatch</strong>: Compilation halts if integrity check fails</li>
<li><strong>Version Control Integration</strong>: Checksum files tracked in git</li>
</ul>
<h3 id="vendor-sources"><a class="header" href="#vendor-sources">Vendor Sources</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Algorithm</th><th>Official Source</th><th>Verification</th></tr></thead><tbody>
<tr><td>ML-KEM</td><td>NIST FIPS 203 Reference</td><td>SHA-256 checksums</td></tr>
<tr><td>ML-DSA</td><td>NIST FIPS 204 Reference</td><td>SHA-256 checksums</td></tr>
<tr><td>Falcon</td><td>NIST PQC Round 3</td><td>SHA-256 checksums</td></tr>
<tr><td>SPHINCS+</td><td>NIST PQC Round 3</td><td>SHA-256 checksums</td></tr>
</tbody></table>
</div>
<h2 id="secure-compilation"><a class="header" href="#secure-compilation">Secure Compilation</a></h2>
<h3 id="security-hardened-compiler-flags"><a class="header" href="#security-hardened-compiler-flags">Security-Hardened Compiler Flags</a></h3>
<p><strong>Stack Protection:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cc.flag("-fstack-protector-strong");      // Stack canary protection
cc.flag("-D_FORTIFY_SOURCE=2");           // Buffer overflow detection
<span class="boring">}</span></code></pre></pre>
<p><strong>Control Flow Integrity:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_os = "linux")]
cc.flag("-fcf-protection=full");          // Intel CET support

#[cfg(target_os = "windows")]
cc.flag("/guard:cf");                     // Windows CFG
<span class="boring">}</span></code></pre></pre>
<p><strong>Memory Safety Hardening:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cc.flag("-fPIE");                         // Position Independent Executable
cc.flag("-Wl,-z,relro");                  // Read-only relocations  
cc.flag("-Wl,-z,now");                    // Immediate symbol resolution
<span class="boring">}</span></code></pre></pre>
<h3 id="platform-specific-security"><a class="header" href="#platform-specific-security">Platform-Specific Security</a></h3>
<p><strong>Linux Security Features:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cc.flag("-fstack-clash-protection");     // Stack clash protection
cc.flag("-fcf-protection=full");         // Control Flow Integrity
cc.flag("-mshstk");                      // Shadow stack (Intel CET)
<span class="boring">}</span></code></pre></pre>
<p><strong>Windows Security Features:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cc.flag("/GS");                         // Stack buffer security check
cc.flag("/guard:cf");                   // Control Flow Guard
cc.flag("/DYNAMICBASE");                // ASLR support
<span class="boring">}</span></code></pre></pre>
<h2 id="ffi-binding-security"><a class="header" href="#ffi-binding-security">FFI Binding Security</a></h2>
<h3 id="api-surface-minimization"><a class="header" href="#api-surface-minimization">API Surface Minimization</a></h3>
<p><strong>Function Allowlisting:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let allowed_functions = vec![
    "crypto_kem_keypair",
    "crypto_kem_enc",
    "crypto_kem_dec",
    "crypto_sign_keypair", 
    "crypto_sign",
    "crypto_sign_open",
    // Only essential cryptographic functions exposed
];
<span class="boring">}</span></code></pre></pre>
<p><strong>Type Restriction:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bindgen_builder
    .allowlist_type("crypto_.*")
    .blocklist_type("internal_.*")           // Block internal details
    .opaque_type("rng_state")               // Opaque sensitive structures
<span class="boring">}</span></code></pre></pre>
<h3 id="security-through-isolation"><a class="header" href="#security-through-isolation">Security Through Isolation</a></h3>
<p><strong>Symbol Visibility Control:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cc.flag("-fvisibility=hidden");              // Hide symbols by default
cc.define("CRYPTO_API", "extern");           // Explicit API marking

// Platform-specific symbol control
#[cfg(target_os = "windows")]
cc.define("CRYPTO_EXPORT", "__declspec(dllexport)");

#[cfg(unix)]  
cc.define("CRYPTO_EXPORT", "__attribute__((visibility(\"default\")))");
<span class="boring">}</span></code></pre></pre>
<p><strong>Static Linking Security:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cc.static_flag(true);                        // Force static linking
cc.shared_flag(false);                       // Prevent DLL injection
cc.flag("-static-libgcc");                   // Static runtime linking
<span class="boring">}</span></code></pre></pre>
<h2 id="build-reproducibility"><a class="header" href="#build-reproducibility">Build Reproducibility</a></h2>
<h3 id="deterministic-compilation"><a class="header" href="#deterministic-compilation">Deterministic Compilation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cc.flag("-frandom-seed=0");                  // Reproducible randomization
cc.env("SOURCE_DATE_EPOCH", "1609459200");  // Reproducible timestamps
cc.flag("-fdebug-prefix-map=/build=.");     // Reproducible debug paths
<span class="boring">}</span></code></pre></pre>
<h3 id="build-audit-trail"><a class="header" href="#build-audit-trail">Build Audit Trail</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("cargo:warning=Building with security flags: {:?}", security_flags);
println!("cargo:warning=Target architecture: {}", target_arch());
println!("cargo:warning=Compiler version: {}", compiler_version());
<span class="boring">}</span></code></pre></pre>
<h2 id="development-build-commands"><a class="header" href="#development-build-commands">Development Build Commands</a></h2>
<h3 id="standard-build"><a class="header" href="#standard-build">Standard Build</a></h3>
<pre><code class="language-bash">cargo build                    # Debug build with all security checks
cargo build --release          # Optimized build with security hardening
</code></pre>
<h3 id="security-validation"><a class="header" href="#security-validation">Security Validation</a></h3>
<pre><code class="language-bash">cargo clippy                   # Static analysis and security lints
cargo test                     # Comprehensive test suite
cargo audit                    # Dependency security audit
</code></pre>
<h3 id="platform-specific-builds"><a class="header" href="#platform-specific-builds">Platform-Specific Builds</a></h3>
<pre><code class="language-bash"># Linux with maximum security features
RUSTFLAGS="-C target-cpu=native" cargo build --release

# Windows with enhanced security
cargo build --target x86_64-pc-windows-msvc --release

# macOS with Apple Silicon optimizations  
cargo build --target aarch64-apple-darwin --release
</code></pre>
<h2 id="continuous-integration-security"><a class="header" href="#continuous-integration-security">Continuous Integration Security</a></h2>
<h3 id="security-validation-pipeline"><a class="header" href="#security-validation-pipeline">Security Validation Pipeline</a></h3>
<ol>
<li><strong>Vendor Integrity Check</strong>: Verify all C code checksums</li>
<li><strong>Compiler Security Audit</strong>: Validate security flags applied</li>
<li><strong>Binary Analysis</strong>: Static analysis of generated binaries</li>
<li><strong>Symbol Analysis</strong>: Verify minimal symbol exposure</li>
<li><strong>Runtime Security Testing</strong>: Validate security features</li>
</ol>
<h3 id="security-regression-prevention"><a class="header" href="#security-regression-prevention">Security Regression Prevention</a></h3>
<ul>
<li>All security flags tracked in version control</li>
<li>Build failures on missing security features</li>
<li>Automated security flag regression detection</li>
<li>Platform-specific security feature validation</li>
</ul>
<p>For complete build system architecture including dependency management and security validation, see the full <a href="development/../../ARCHITECTURE.html">Architecture Documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-and-validation-1"><a class="header" href="#testing-and-validation-1">Testing and Validation</a></h1>
<p>Cypheron Core implements comprehensive testing across multiple validation layers to ensure NIST compliance, cryptographic correctness, and security properties.</p>
<p>For complete technical details, see <a href="development/../../ARCHITECTURE.html#testing-and-validation-architecture">Architecture Documentation</a>.</p>
<h2 id="testing-categories"><a class="header" href="#testing-categories">Testing Categories</a></h2>
<h3 id="1-known-answer-tests-kat"><a class="header" href="#1-known-answer-tests-kat">1. Known Answer Tests (KAT)</a></h3>
<p><strong>Purpose:</strong> NIST compliance validation using official test vectors</p>
<pre><code class="language-bash">cargo test kat_                # Run all KAT tests
cargo test ml_kem_kat         # ML-KEM specific KAT  
cargo test ml_dsa_kat         # ML-DSA specific KAT
</code></pre>
<p><strong>Coverage:</strong></p>
<ul>
<li>FIPS 203 (ML-KEM) compliance validation</li>
<li>FIPS 204 (ML-DSA) compliance validation</li>
<li>Parameter compliance verification</li>
<li>Cross-platform consistency testing</li>
</ul>
<h3 id="2-property-based-testing"><a class="header" href="#2-property-based-testing">2. Property-Based Testing</a></h3>
<p><strong>Purpose:</strong> Cryptographic property verification using proptest</p>
<pre><code class="language-bash">cargo test property_          # All property-based tests
cargo test correctness_       # Cryptographic correctness
cargo test roundtrip_         # Encryption/decryption cycles
</code></pre>
<p><strong>Properties Verified:</strong></p>
<ul>
<li>Key generation produces valid keypairs</li>
<li>Encryption/decryption roundtrip correctness</li>
<li>Signature generation/verification consistency</li>
<li>Hybrid cryptography composition properties</li>
</ul>
<h3 id="3-security-analysis-testing"><a class="header" href="#3-security-analysis-testing">3. Security Analysis Testing</a></h3>
<p><strong>Purpose:</strong> Security vulnerability detection and validation</p>
<pre><code class="language-bash">cargo test security_          # Security-focused tests
cargo test timing_            # Basic timing attack detection  
cargo test memory_safety_     # Memory safety validation
</code></pre>
<p><strong>Security Testing:</strong></p>
<ul>
<li>Memory safety validation with sanitizers</li>
<li>Basic timing attack resistance</li>
<li>Buffer boundary protection testing</li>
<li>FFI safety validation</li>
</ul>
<h3 id="4-fuzzing-infrastructure"><a class="header" href="#4-fuzzing-infrastructure">4. Fuzzing Infrastructure</a></h3>
<p><strong>Purpose:</strong> Robustness testing with malformed and edge-case inputs</p>
<pre><code class="language-bash"># Install cargo-fuzz
cargo install cargo-fuzz

# Run fuzzing campaigns
cargo fuzz run fuzz_ml_kem    # ML-KEM fuzzing
cargo fuzz run fuzz_ml_dsa    # ML-DSA fuzzing  
cargo fuzz run fuzz_hybrid    # Hybrid crypto fuzzing
</code></pre>
<p><strong>Fuzzing Targets:</strong></p>
<ul>
<li>Algorithm input validation</li>
<li>FFI boundary robustness</li>
<li>Error handling completeness</li>
<li>Memory safety under stress</li>
</ul>
<h3 id="5-performance-benchmarking"><a class="header" href="#5-performance-benchmarking">5. Performance Benchmarking</a></h3>
<p><strong>Purpose:</strong> Performance regression detection and analysis</p>
<pre><code class="language-bash">cargo bench                   # Run all benchmarks
cargo bench ml_kem           # ML-KEM performance
cargo bench signatures       # Signature algorithm performance
</code></pre>
<p><strong>Performance Metrics:</strong></p>
<ul>
<li>Key generation timing</li>
<li>Encryption/decryption performance</li>
<li>Signature generation/verification speed</li>
<li>Memory usage analysis</li>
</ul>
<h2 id="nist-compliance-testing"><a class="header" href="#nist-compliance-testing">NIST Compliance Testing</a></h2>
<h3 id="test-vector-validation"><a class="header" href="#test-vector-validation">Test Vector Validation</a></h3>
<p>The KAT implementation validates against official NIST test vectors:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_ml_kem_768_kat() {
    // Load NIST test vectors
    let test_vectors = load_nist_kat_vectors("ML-KEM-768");
    
    for vector in test_vectors {
        // Validate key generation
        let (pk, sk) = MlKem768::keypair_deterministic(&amp;vector.seed)?;
        assert_eq!(pk.as_bytes(), &amp;vector.public_key);
        assert_eq!(sk.as_bytes(), &amp;vector.secret_key);
        
        // Validate encapsulation  
        let (ct, ss) = MlKem768::encapsulate_deterministic(&amp;pk, &amp;vector.enc_seed)?;
        assert_eq!(ct.as_bytes(), &amp;vector.ciphertext);
        assert_eq!(ss.expose_secret(), &amp;vector.shared_secret);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_algorithm_integration() {
    // Cross-algorithm compatibility
    test_hybrid_kem_dsa_integration();
    
    // Platform consistency
    test_cross_platform_compatibility();
    
    // Error handling
    test_comprehensive_error_cases();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-testing-1"><a class="header" href="#security-testing-1">Security Testing</a></h2>
<h3 id="memory-safety-testing-1"><a class="header" href="#memory-safety-testing-1">Memory Safety Testing</a></h3>
<pre><code class="language-bash"># AddressSanitizer
RUSTFLAGS="-Zsanitizer=address" cargo test

# MemorySanitizer  
RUSTFLAGS="-Zsanitizer=memory" cargo test

# ThreadSanitizer
RUSTFLAGS="-Zsanitizer=thread" cargo test
</code></pre>
<h3 id="ffi-boundary-testing"><a class="header" href="#ffi-boundary-testing">FFI Boundary Testing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_ffi_boundary_safety() {
    // Buffer boundary validation
    test_buffer_overflow_protection();
    
    // Null pointer handling
    test_null_pointer_safety();
    
    // Invalid input handling
    test_malformed_input_handling();
    
    // Error propagation
    test_c_error_handling();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="timing-analysis"><a class="header" href="#timing-analysis">Timing Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_timing_side_channels() {
    // Basic constant-time validation
    let measurements = measure_operation_timing();
    validate_timing_consistency(&amp;measurements);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="development-testing-workflow"><a class="header" href="#development-testing-workflow">Development Testing Workflow</a></h2>
<h3 id="pre-commit-testing"><a class="header" href="#pre-commit-testing">Pre-Commit Testing</a></h3>
<pre><code class="language-bash">#!/bin/bash
# scripts/pre-commit-test.sh

# Format check
cargo fmt --check

# Lint check  
cargo clippy -- -D warnings

# Unit tests
cargo test --all

# Integration tests
cargo test --test integration

# Documentation tests
cargo test --doc
</code></pre>
<h3 id="continuous-integration-testing"><a class="header" href="#continuous-integration-testing">Continuous Integration Testing</a></h3>
<pre><code class="language-yaml"># .github/workflows/test.yml (excerpt)
- name: Security Testing
  run: |
    # Memory safety testing
    RUSTFLAGS="-Zsanitizer=address" cargo test
    
    # Dependency audit
    cargo audit
    
    # Security lints
    cargo clippy -- -D warnings -W clippy::all
</code></pre>
<h3 id="platform-testing-matrix"><a class="header" href="#platform-testing-matrix">Platform Testing Matrix</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Rust Version</th><th>Test Suite</th><th>Additional Validation</th></tr></thead><tbody>
<tr><td>Linux x86_64</td><td>stable, beta, nightly</td><td>Full</td><td>AddressSanitizer, Valgrind</td></tr>
<tr><td>macOS x86_64</td><td>stable</td><td>Full</td><td>Instruments profiling</td></tr>
<tr><td>macOS ARM64</td><td>stable</td><td>Full</td><td>Apple Silicon validation</td></tr>
<tr><td>Windows x86_64</td><td>stable</td><td>Full</td><td>Visual Studio analysis</td></tr>
</tbody></table>
</div>
<h2 id="test-data-management"><a class="header" href="#test-data-management">Test Data Management</a></h2>
<h3 id="nist-test-vectors"><a class="header" href="#nist-test-vectors">NIST Test Vectors</a></h3>
<pre><code>tests/data/
├── kat/
│   ├── ml-kem-512.rsp        # NIST KAT for ML-KEM-512
│   ├── ml-kem-768.rsp        # NIST KAT for ML-KEM-768
│   ├── ml-kem-1024.rsp       # NIST KAT for ML-KEM-1024
│   ├── ml-dsa-44.rsp         # NIST KAT for ML-DSA-44
│   └── ...
└── vectors/
    ├── property_test_seeds.txt
    └── fuzzing_corpus/
</code></pre>
<h3 id="test-coverage-reporting"><a class="header" href="#test-coverage-reporting">Test Coverage Reporting</a></h3>
<pre><code class="language-bash"># Generate coverage report
cargo install cargo-tarpaulin
cargo tarpaulin --out Html --output-dir coverage/

# View coverage report
open coverage/tarpaulin-report.html
</code></pre>
<h2 id="contributing-testing"><a class="header" href="#contributing-testing">Contributing Testing</a></h2>
<h3 id="adding-new-tests"><a class="header" href="#adding-new-tests">Adding New Tests</a></h3>
<ol>
<li><strong>Unit Tests</strong>: Add alongside implementation in <code>src/</code></li>
<li><strong>Integration Tests</strong>: Add to <code>tests/</code> directory</li>
<li><strong>KAT Tests</strong>: Update with new NIST vectors when available</li>
<li><strong>Property Tests</strong>: Add to <code>tests/property/</code></li>
<li><strong>Fuzzing</strong>: Add new fuzz targets in <code>fuzz/</code></li>
</ol>
<h3 id="test-quality-standards"><a class="header" href="#test-quality-standards">Test Quality Standards</a></h3>
<ul>
<li><strong>Comprehensive Coverage</strong>: All public APIs tested</li>
<li><strong>Edge Case Testing</strong>: Boundary conditions validated</li>
<li><strong>Error Path Testing</strong>: All error conditions exercised</li>
<li><strong>Performance Testing</strong>: No performance regressions</li>
<li><strong>Security Testing</strong>: Security properties validated</li>
</ul>
<p>For complete testing architecture including specific test implementations and validation methodologies, see the full <a href="development/../../ARCHITECTURE.html">Architecture Documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-codes-reference"><a class="header" href="#error-codes-reference">Error Codes Reference</a></h1>
<p>Complete reference for all error codes in Cypheron Core.</p>
<h2 id="kem-errors-1"><a class="header" href="#kem-errors-1">KEM Errors</a></h2>
<h3 id="error-kem-001"><a class="header" href="#error-kem-001">ERROR-KEM-001</a></h3>
<p><strong>Key Generation Entropy Failure</strong></p>
<p><strong>Cause:</strong> Insufficient entropy available for key generation.</p>
<p><strong>Solution:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Ensure your system has adequate entropy
// On Linux: check /proc/sys/kernel/random/entropy_avail
// Consider using hardware RNG if available

use cypheron_core::kem::{MlKem768, Kem};

// Retry with backoff
for attempt in 1..=3 {
    match MlKem768::keypair() {
        Ok(keys) =&gt; return Ok(keys),
        Err(e) if attempt &lt; 3 =&gt; {
            std::thread::sleep(std::time::Duration::from_millis(100 * attempt));
            continue;
        },
        Err(e) =&gt; return Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-kem-002"><a class="header" href="#error-kem-002">ERROR-KEM-002</a></h3>
<p><strong>Decapsulation Invalid Ciphertext</strong></p>
<p><strong>Cause:</strong> Ciphertext was corrupted or not generated with the corresponding public key.</p>
<p><strong>Solution:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::{MlKem768, Kem};

let (pk, sk) = MlKem768::keypair().unwrap();
let (ct, ss1) = MlKem768::encapsulate(&amp;pk).unwrap();

// Verify ciphertext length before decapsulation
if ct.len() != 1088 { // ML-KEM-768 ciphertext size
    return Err("Invalid ciphertext size");
}

match MlKem768::decapsulate(&amp;ct, &amp;sk) {
    Ok(shared_secret) =&gt; { /* success */ },
    Err(e) =&gt; {
        // Check if ciphertext is corrupted
        // Verify it was generated with correct public key
        eprintln!("Decapsulation failed: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-kem-003"><a class="header" href="#error-kem-003">ERROR-KEM-003</a></h3>
<p><strong>Encapsulation Invalid Public Key</strong></p>
<p><strong>Cause:</strong> Public key format is invalid or corrupted.</p>
<p><strong>Solution:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Validate public key before use
use cypheron_core::kem::{MlKem768, Kem};

fn validate_public_key(pk_bytes: &amp;[u8]) -&gt; Result&lt;(), &amp;'static str&gt; {
    if pk_bytes.len() != 1184 { // ML-KEM-768 public key size
        return Err("Invalid public key size");
    }
    // Additional validation logic...
    Ok(())
}

// Use validated public key
if let Err(e) = validate_public_key(&amp;pk_bytes) {
    return Err(format!("Public key validation failed: {}", e));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="signature-errors-1"><a class="header" href="#signature-errors-1">Signature Errors</a></h2>
<h3 id="error-sig-001"><a class="header" href="#error-sig-001">ERROR-SIG-001</a></h3>
<p><strong>Signature Generation Failed</strong></p>
<p><strong>Cause:</strong> Internal error during signature generation, possibly due to entropy issues.</p>
<p><strong>Solution:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::sig::{MlDsa65, SignatureEngine};

let message = b"message to sign";
let (pk, sk) = MlDsa65::keypair().unwrap();

match MlDsa65::sign(message, &amp;sk) {
    Ok(signature) =&gt; { /* success */ },
    Err(e) =&gt; {
        // Check message size (ML-DSA has no message size limit)
        // Verify secret key integrity
        // Ensure adequate system entropy
        eprintln!("Signature generation failed: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-sig-002"><a class="header" href="#error-sig-002">ERROR-SIG-002</a></h3>
<p><strong>Signature Verification Failed</strong></p>
<p><strong>Cause:</strong> Signature is invalid, message was modified, or wrong public key used.</p>
<p><strong>Solution:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::sig::{MlDsa65, SignatureEngine};

// Ensure exact message match
let original_message = b"Hello, world!";
let modified_message = b"Hello, world?"; // Note the different punctuation

let (pk, sk) = MlDsa65::keypair().unwrap();
let signature = MlDsa65::sign(original_message, &amp;sk).unwrap();

// This will fail
let valid = MlDsa65::verify(modified_message, &amp;signature, &amp;pk);
assert!(!valid); // Verification fails due to message modification

// This will succeed  
let valid = MlDsa65::verify(original_message, &amp;signature, &amp;pk);
assert!(valid);
<span class="boring">}</span></code></pre></pre>
<h2 id="hybrid-errors"><a class="header" href="#hybrid-errors">Hybrid Errors</a></h2>
<h3 id="error-hybrid-001"><a class="header" href="#error-hybrid-001">ERROR-HYBRID-001</a></h3>
<p><strong>Composite Key Generation Failed</strong></p>
<p><strong>Cause:</strong> Failure in either classical or post-quantum key generation.</p>
<p><strong>Solution:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::hybrid::{EccDilithium, HybridEngine};

// Retry hybrid key generation with error isolation
match EccDilithium::keypair() {
    Ok(keys) =&gt; { /* success */ },
    Err(e) =&gt; {
        // Error could be from ECC or ML-DSA component
        // Check system entropy and crypto library status
        eprintln!("Hybrid key generation failed: {}", e);
        
        // Consider fallback to individual algorithms for debugging
        use cypheron_core::sig::{MlDsa44, SignatureEngine};
        let pq_test = MlDsa44::keypair();
        match pq_test {
            Ok(_) =&gt; println!("Post-quantum component working"),
            Err(e) =&gt; println!("Post-quantum issue: {}", e),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="platform-specific-errors"><a class="header" href="#platform-specific-errors">Platform-Specific Errors</a></h2>
<h3 id="error-platform-001"><a class="header" href="#error-platform-001">ERROR-PLATFORM-001</a></h3>
<p><strong>Windows Entropy Source Unavailable</strong></p>
<p><strong>Cause:</strong> Windows CryptoAPI is not accessible.</p>
<p><strong>Solution:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Ensure Windows CryptoAPI is available
// This is rare but can happen in restricted environments

#[cfg(target_os = "windows")]
fn check_windows_crypto() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // The library will automatically fallback to other entropy sources
    // but you can manually check availability
    
    use cypheron_core::platform::secure_random_bytes;
    let mut buffer = vec![0u8; 32];
    secure_random_bytes(&amp;mut buffer)?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="memory-errors"><a class="header" href="#memory-errors">Memory Errors</a></h2>
<h3 id="error-mem-001"><a class="header" href="#error-mem-001">ERROR-MEM-001</a></h3>
<p><strong>Secure Memory Allocation Failed</strong></p>
<p><strong>Cause:</strong> System cannot allocate secure memory for sensitive operations.</p>
<p><strong>Solution:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Reduce memory pressure or increase available memory
// Check system memory limits and available RAM

use cypheron_core::kem::{MlKem512, Kem}; // Use smaller variant if needed

// Consider using smaller security parameters temporarily
let (pk, sk) = MlKem512::keypair()?; // Instead of MlKem1024
<span class="boring">}</span></code></pre></pre>
<h2 id="ffi-errors"><a class="header" href="#ffi-errors">FFI Errors</a></h2>
<h3 id="error-ffi-001"><a class="header" href="#error-ffi-001">ERROR-FFI-001</a></h3>
<p><strong>C Library Binding Failed</strong></p>
<p><strong>Cause:</strong> Underlying C library call failed.</p>
<p><strong>Solution:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This indicates an issue with the vendor C implementations
// Usually due to memory corruption or invalid parameters

// Enable debug logging to get more details
std::env::set_var("RUST_LOG", "debug");
env_logger::init();

// The error will include more detailed information in debug mode
<span class="boring">}</span></code></pre></pre>
<h2 id="debugging-tips"><a class="header" href="#debugging-tips">Debugging Tips</a></h2>
<h3 id="enable-detailed-logging"><a class="header" href="#enable-detailed-logging">Enable Detailed Logging</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">// Add to your Cargo.toml
[dependencies]
env_logger = "0.10"

// In your code
fn main() {
    env_logger::init();
    // Your code here - errors will include more details
}</code></pre></pre>
<h3 id="validate-input-data"><a class="header" href="#validate-input-data">Validate Input Data</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cypheron_core::kem::{MlKem768, Kem};

fn safe_decapsulate(ct: &amp;[u8], sk: &amp;SecretKey) -&gt; Result&lt;SharedSecret, String&gt; {
    // Validate ciphertext size
    if ct.len() != 1088 {
        return Err(format!("Invalid ciphertext size: expected 1088, got {}", ct.len()));
    }
    
    // Additional validation...
    
    MlKem768::decapsulate(ct, sk)
        .map_err(|e| format!("Decapsulation failed: {}", e))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="test-with-known-good-data"><a class="header" href="#test-with-known-good-data">Test with Known Good Data</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_with_known_vectors() {
        // Use NIST test vectors for validation
        // See tests/kat/ directory for examples
        let (pk, sk) = MlKem768::keypair().unwrap();
        let (ct, ss1) = MlKem768::encapsulate(&amp;pk).unwrap();
        let ss2 = MlKem768::decapsulate(&amp;ct, &amp;sk).unwrap();
        assert_eq!(ss1.expose_secret(), ss2.expose_secret());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h2>
<p>If you encounter an error not covered here:</p>
<ol>
<li><strong>Check the <a href="troubleshooting/faq.html">FAQ</a></strong> for common solutions</li>
<li><strong>Enable debug logging</strong> to get more details</li>
<li><strong>Search <a href="https://github.com/CypheronLabs/Cypheron-core/issues">GitHub Issues</a></strong></li>
<li><strong>Create a minimal reproduction case</strong></li>
<li><strong>File a new issue</strong> with full error details</li>
</ol>
<h2 id="see-also-7"><a class="header" href="#see-also-7">See Also</a></h2>
<ul>
<li><a href="troubleshooting/common.html">Common Issues</a> - Frequent problems and solutions</li>
<li><a href="troubleshooting/debug.html">Debug Guide</a> - Advanced debugging techniques</li>
<li><a href="troubleshooting/../api/errors.html">API Reference</a> - Error type documentation</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/custom.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
